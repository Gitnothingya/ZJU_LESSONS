[TOC]

### 补充修改

1. parse_tree.c  24与29行





select * from t1 where id = 1 or name = "str" or age is null or bb not null;

### 问题

1. memheap是个啥

2. database init参数？

### 实现

#### 执行器构造函数

>打开 数据库存档文件 minisqlSave
>
>将所有数据库名称存下来
>
>遍历容器，构造数据库引擎，init参数false（$\textcolor{red}{后期检查初始化参数是否正确，有想要的效果}$）
>
>

#### 创建数据库

>create database db0;
>
>判断语法树有意义
>
>数据库存在 fail
>
>不存在  创建并返回sucess

```c++
```



#### 删除数据库

>drop database db0;与创建相反
>
>判断语法树有意义
>
>不存在  fail
>
>存在 删除
>
>！！！！！不仅要析构数据库引擎，还要删除对应键值对
>
>如果正在使用数据库

```c++
```



#### 显示数据库

>show databases;
>
>遍历dbs_；
>
>$\textcolor{red}{存在错误吗？？？？？？}$

```c++
```



#### 使用数据库

>use db0;
>
>修改当前使用数据库名
>
>不存在须报错，使用count判断
>
>![image-20220605121000241](D:\dblab\补充修改\image\image-20220605121000241.png)

```c++

```



#### 显示表

>show tables;

```c++
```

#### 创建表

```sql
create table t1(a int, b char(20) unique, c float, primary key(a, c));
create table t1(a int, b char(0) unique, c float, primary key(a, c));
create table t1(a int, b char(-5) unique, c float, primary key(a, c));
create table t1(a int, b char(3.69) unique, c float, primary key(a, c));
create table t1(a int, b char(-0.69) unique, c float, primary key(a, c));
create table student(
  sno char(8),
  sage int,
  sab float unique,
  primary key (sno, sab)
);

```

>属于主键的元素都不能为空；
>
>遍历完所有节点再建立；
>
>创建主键索引；



#### 删除表

```sql
drop table t1;
```

>直接调用catalog函数
>
>~~索引？~~ （$\textcolor{red}{yyb待修改}$）删除索引处未删indexes_names_
>
>



#### 显示索引

```sql
show indexes;
```



```c++
```



#### 创建索引

```sql
create index idx1 on t1(a, b);
-- "btree" can be replaced with other index types
create index idx1 on t1(a, b) using btree;
```

>只能在唯一键上建立索引
>
>判断重复（列类 新增重复取值函数）
>
>

#### 删除索引

```sql
drop index idx1;
```



#### 选择

```sql
select * from t1;
select id, name from t1;
select * from t1 where id = 1;
-- note: use left association
select * from t1 where id = 1 and name = "str";
select * from t1 where id = 1 and name = "str" or age is null and bb not null;
```

>使用索引进行单个查找，范围查找未实现
>
>

#### 插入

```sql
insert into t1 values(1, "aaa", null, 2.33);
-- values 关键字必加s
-- 插入顺序不对要判断
```

>得到表名，检查表模式（列属性）
>
>逐一构造比对数据
>
>
>
>插入时row为局部变量即可，传入引用，返回时会得到id，再维护索引。
>
>
>
>
>
>错误种类
>
>1. 类型无法对上
>2. 
>
>

#### 删除

```sql
delete from t1;
delete from t1 where id = 1 and amount = 2.33;
```



#### 更新

```sql
update t1 set c = 3;
update t1 set a = 1, b = "ccc" where b = 2.33;
```



#### 文件执行

```sql
execfile "a.txt";
```



#### 退出

```sql
quit;
将所有数据库文件名存档 minisqlSave
```



### 所有语法节点

```c++
(yyval.syntax_node) = CreateSyntaxNode(kNodeCreateDB, NULL);
(yyval.syntax_node) = CreateSyntaxNode(kNodeDropDB, NULL);
(yyval.syntax_node) = CreateSyntaxNode(kNodeShowDB, NULL);
(yyval.syntax_node) = CreateSyntaxNode(kNodeUseDB, NULL);
(yyval.syntax_node) = CreateSyntaxNode(kNodeShowTables, NULL);
(yyval.syntax_node) = CreateSyntaxNode(kNodeCreateTable, NULL);
CreateSyntaxNode(kNodeColumnDefinitionList, NULL);
CreateSyntaxNode(kNodeColumnList, "primary keys");
CreateSyntaxNode(kNodeColumnDefinition, "unique");
CreateSyntaxNode(kNodeColumnDefinition, NULL);
CreateSyntaxNode(kNodeColumnType, "int");
CreateSyntaxNode(kNodeColumnType, "float");
CreateSyntaxNode(kNodeColumnType, "char");
CreateSyntaxNode(kNodeDropTable, NULL);

CreateSyntaxNode(kNodeCreateIndex, NULL);
CreateSyntaxNode(kNodeColumnList, "index keys");
CreateSyntaxNode(kNodeCreateIndex, NULL);
CreateSyntaxNode(kNodeColumnList, "index keys");
CreateSyntaxNode(kNodeIndexType, "index type");
CreateSyntaxNode(kNodeDropIndex, NULL);
CreateSyntaxNode(kNodeShowIndexes, NULL);
CreateSyntaxNode(kNodeSelect, NULL);
CreateSyntaxNode(kNodeSelect, NULL);
CreateSyntaxNode(kNodeConditions, NULL);
CreateSyntaxNode(kNodeAllColumns, NULL);
CreateSyntaxNode(kNodeColumnList, "select columns");
CreateSyntaxNode(kNodeConnector, "and");
CreateSyntaxNode(kNodeConnector, "or");
CreateSyntaxNode(kNodeNull, NULL);
CreateSyntaxNode(kNodeCompareOperator, "=");
CreateSyntaxNode(kNodeCompareOperator, "<>");
CreateSyntaxNode(kNodeCompareOperator, "<=");
CreateSyntaxNode(kNodeCompareOperator, ">=");
CreateSyntaxNode(kNodeCompareOperator, "<");
CreateSyntaxNode(kNodeCompareOperator, ">");
CreateSyntaxNode(kNodeCompareOperator, "is");
CreateSyntaxNode(kNodeCompareOperator, "not");
CreateSyntaxNode(kNodeInsert, NULL);
CreateSyntaxNode(kNodeColumnValues, NULL);

CreateSyntaxNode(kNodeDelete, NULL);
CreateSyntaxNode(kNodeDelete, NULL);
CreateSyntaxNode(kNodeConditions, NULL);

CreateSyntaxNode(kNodeUpdate, NULL);
CreateSyntaxNode(kNodeUpdateValues, NULL);
CreateSyntaxNode(kNodeUpdate, NULL);
 CreateSyntaxNode(kNodeUpdateValues, NULL);
CreateSyntaxNode(kNodeConditions, NULL);
CreateSyntaxNode(kNodeUpdateValue, NULL);

CreateSyntaxNode(kNodeTrxBegin, NULL);
CreateSyntaxNode(kNodeTrxCommit, NULL);
CreateSyntaxNode(kNodeTrxRollback, NULL);

CreateSyntaxNode(kNodeQuit, NULL);
CreateSyntaxNode(kNodeExecFile, NULL);




CreateSyntaxNode(kNodeString, yytext);
CreateSyntaxNode(kNodeIdentifier, yytext);
CreateSyntaxNode(kNodeNumber, yytext);
CreateSyntaxNode(kNodeNumber, yytext);
```

不分析单引号，

字符串加”“

null可分析但是实现被阻塞了













![image-20220608182329413](D:\dblab\补充修改\image\image-20220608182329413.png)

？有什么不同吗？



typeInt typefloat 没有getdata;





插入时第二个会出现 莫名rowid的情况

