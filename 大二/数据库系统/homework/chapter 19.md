### chapter 19

19.2

>检查点可以减少崩溃后的回复时间，如果没有检查点，崩溃后我们必须检索整个日志，而且日志中的所有事物都要撤销或重做。有了检查点后，就可以忽略检查点前的大部分日志记录了。同时，在存储空间满了后，我们可以以检查点为参照删除日志记录，释放空间。
>
>检查点对于性能有一定的影响，因此检查点的设置需要根据系统的崩溃频率来确认频率。
>
>对于稳定无崩溃发生的系统，检查点的频率应该尽可能少。
>
>而针对系统恢复，如果我们对恢复速度没有需求，可以减少检查点设置；如果我们需要快速恢复系统，就需要频繁设置检查点。
>
>检查点的频率对于磁盘崩溃的恢复没有影响。

19.10

>因为交互式事务的一些输出可能是不可撤销的，比如ATM机将钱吐出给客户。我们可以将所有输出放到事务的末尾，这样的话即使事务执行过程中被终止，也不会有无法挽回的损失。比如ATM机取钱时在结束时一次性给出所有钱而不是一张一张吐出。

19.21

>重做阶段：
>
>a. 设定 Undo-List = T0,T1;
>
>b. 从检查点开始执行重做操作
>
>c. C = 600;
>
>d. 因为<T1,commit>T1的提交记录，T1从Undo-List中去除
>
>e. 因为 <T2 start> 的T2起始记录，T2被加入 Undo-List。
>
>f. A = 400;
>
>g. B = 2000;
>
>撤销阶段：
>
>a. Undo - List = T0, T2;
>
>b. 从后往前检查日志
>
>c. A = 500; 输出redo-only日志记录 <T2,A,500>
>
>d. 输出 <T2 abort>
>
>e. B = 2000;输出redo-only 日志记录<T0,B,2000>
>
>f. 输出 <T0 abort>
>
>最终系统的状态：A = 500; B = 2000; C =600;
>
>日志中添加了几条记录：<T2,A,500> ，<T2 abort>，<T0,B,2000>，<T0 abort>

19.25

>a. 如果某一页再分析开始时并不在检查点脏页表中，那么它并不需要执行检查点之前的记录重做，因为它已经在磁盘中了。但是，如果该页可能在检查点之后更新，即它可能在分析结束时出现在脏页表中。对于出现在脏页表中的页，还需要对检查前的记录进行重做。
>
>b. RecLSN 是脏页表中的一个条目，对应了页面被加入脏页表时日志末的LSN。在ARIES算法的重做过程中，如果遇到的日志更新记录的LSN小于该页在脏页表中的RecLES，那么该条记录被跳过，无需重做。另外，重做过程从RedoLSN开始，因为它是检查点脏页表中最早的一条RecLSN，而更早的日志记录不需要重做了。
>
>









