#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
typedef struct memnode* memnodep;

struct memnode{
	int loc;			//address	
	char data[17];
	memnodep next; 
	memnodep front;
};
memnodep MEM;			//Start location of memory
short int reg[8]={30583,30583,30583,30583,30583,30583,30583,30583};       		//register
int PC;                	 
memnodep  memp;		   	//A pointer used to access memory 
int  MAR;				 
char MDR[17];			 
int nzp[3]={0,1,0};				 


int numconvert(char snum[], int n);
void dectobits(int dec,char bits[17]);

extern memnodep newlist();
memnodep addnode(memnodep last,int aloc,char adata[]);
void scanfI();


void executor(); 				//Executing instructions one by one
memnodep findloc(int n);		//find the pointer to the address which store the data we neeed 
int readfun(char ch[17]);		//According to bit[15:12] to distinguish instructions
void BR(char ch[17]);			//0000		0
void ADD(char ch[17]);			//0001		1
void AND(char ch[17]);			//0101		5 
void NOT(char ch[17]);			//1001		9 
void JMP(char ch[17]);			//1100		12
void JSR(char ch[17]);			//0100		4
void LD(char ch[17]);			//0010		2
void LDI(char ch[17]);			//1010		10
void LDR(char ch[17]);			//0110		6
void LEA(char ch[17]);			//1110		14
void ST(char ch[17]);			//0011		3
void STI(char ch[17]);			//1011		11
void STR(char ch[17]);			//0111		7


void presult();					//print the result 


extern memnodep newlist()
{
	memnodep headmem=(memnodep)malloc(sizeof(struct memnode));
	headmem->front=NULL;
	headmem->next=NULL;
	return headmem;
}

memnodep addnode(memnodep last,int aloc,char adata[])
{
	int i;
	memnodep newnode=(memnodep)malloc(sizeof(struct memnode));	
	newnode->loc = aloc;
	strcpy(newnode->data,adata);

	if(last->next==NULL){
		newnode->front=last;
		newnode->next=NULL;
		last->next=newnode;
	}
	else if(last->next!=NULL){
		memnodep store=last->next;
		last->next=newnode;
		store->front=newnode;
		newnode->front=last;
		newnode->next= store;
	}
	return newnode;
}

void scanfI()
{
	memnodep addp=MEM;
	char ch[17];
	int location;
	scanf("%s",ch);
	location=numconvert(ch,16);
	PC=location;
	while(scanf("%s",ch)!=EOF){
		addp=addnode(addp,location,ch);
		location++;
	}
	return ;
}

void executor()
{
	PC=MEM->next->loc;
	while(1)
	{
		MAR=PC;
		PC=PC+1; 
		memp=findloc(MAR);
		strcpy(MDR,memp->data);
		int ir;
		ir=readfun(MDR);
		switch(ir)
		{
			case 0:
				BR(MDR);
				break;
			case 1:
				ADD(MDR);
				break;
			case 2:
				LD(MDR);
				break;
			case 3:
				ST(MDR);
				break;
			case 4:
				JSR(MDR);
				break;
			case 5:
				AND(MDR);
				break;
			case 6:
				LDR(MDR);
				break;
			case 7:
				STR(MDR);
				break;
			case 9:
				NOT(MDR);
				break;
			case 10:
				LDI(MDR);
				break;
			case 11:
				STI(MDR);
				break;
			case 12:
				JMP(MDR);
				break;
			case 14:
				LEA(MDR);
				break;
			case 15:
				return ;
				break;
			default:
				break;
		}
	}
	return ; 
}

memnodep findloc(int n)
{
	memnodep findp;
	findp=MEM->next;
	while(findp!=NULL&&findp->loc<=n)
	{
		if(findp->loc==n)return findp;
		else findp=findp->next;
	}
	if(findp==NULL){
		findp=MEM->next;
		while(findp->next!=NULL)findp=findp->next;
		findp=addnode(findp,n,"0111011101110111");
	}
	else if(findp!=NULL){
		findp=findp->front;
		findp=addnode(findp,n,"0111011101110111");
	}
	return findp;
}
 
int readfun(char ch[17])
{
	char tempch[5];
	int i;
	for(i=0;i<4;i++){
		tempch[i]=ch[i];
	}
	tempch[5]='\0';
	return numconvert(tempch,4);
}

void BR(char ch[17])			//0000		0
{
	if((ch[4]=='1'&&nzp[0]==1) || (ch[5]=='1'&&nzp[1]==1) || (ch[6]=='1'&&nzp[2]==1)){
		char offch[10];
		short int offset;
		int i;
		for(i=0;i<9;i++){
			offch[i]=ch[i+7];
		}
		offset=numconvert(offch,9);
		PC=PC+offset;
	} 
	return ;
}
void ADD(char ch[17])			//0001		1
{
	char numch[5];
	int DR,SR1;
	int i;
	for(i=0;i<3;i++){
		numch[i]=ch[i+4];
	}
	DR=numconvert(numch,3);
	for(i=0;i<3;i++){
		numch[i]=ch[i+7];
	}
	SR1=numconvert(numch,3);
	
	if(ch[10]=='0'){
		int SR2;
		for(i=0;i<3;i++){
			numch[i]=ch[i+13];
		}
		SR2=numconvert(numch,3);
		reg[DR]=reg[SR1]+reg[SR2];
	}
	else if(ch[10]=='1'){
		int imm;
		for(i=0;i<5;i++){
			numch[i]=ch[i+11];
		}
		imm=numconvert(numch,5);
		reg[DR]=reg[SR1]+imm;
	}
	short int cmp=reg[DR];
	for(i=0;i<3;i++){
		nzp[i]=0;
	}
	if(cmp>0) nzp[2]=1;
	else if(cmp<0) nzp[0]=1;
	else if(cmp==0) nzp[1]=1;
	return ;
	
} 
void AND(char ch[17])			//0101		5 
{
	char numch[5];
	int DR,SR1;
	int i;
	for(i=0;i<3;i++){
		numch[i]=ch[i+4];
	}
	DR=numconvert(numch,3);
	for(i=0;i<3;i++){
		numch[i]=ch[i+7];
	}
	SR1=numconvert(numch,3);
	
	if(ch[10]=='0'){
		int SR2;
		for(i=0;i<3;i++){
			numch[i]=ch[i+13];
		}
		SR2=numconvert(numch,3);
		reg[DR]=reg[SR1]&reg[SR2];
	}
	else if(ch[10]=='1'){
		int imm;
		for(i=0;i<5;i++){
			numch[i]=ch[i+11];
		}
		imm=numconvert(numch,5);
		reg[DR]=reg[SR1]&imm;
	}
	short int cmp=reg[DR];
	for(i=0;i<3;i++){
		nzp[i]=0;
	}
	if(cmp>0) nzp[2]=1;
	else if(cmp<0) nzp[0]=1;
	else if(cmp==0) nzp[1]=1;
	return ;
}

void NOT(char ch[17])			//1001		9 
{
	char numch[3];
	int i;
	int DR,SR;
	char tempch[17];
	
	for(i=0;i<3;i++){
		numch[i]=ch[i+4];
	}
	DR=numconvert(numch,3);
	for(i=0;i<3;i++){
		numch[i]=ch[i+7];
	}
	SR=numconvert(numch,3);
	dectobits(reg[SR],tempch);
	for(i=0;i<16;i++){
		if(tempch[i]=='0')tempch[i]='1';
		else if(tempch[i]=='1')tempch[i]='0';
	}
	reg[DR]=numconvert(tempch,16);
	short int cmp=reg[DR];
	for(i=0;i<3;i++){
		nzp[i]=0;
	}
	if(cmp>0) nzp[2]=1;
	else if(cmp<0) nzp[0]=1;
	else if(cmp==0) nzp[1]=1;
	return ;
}

void JMP(char ch[17])			//1100		12
{
	char numch[3];
	int baseR;
	int i;
	for(i=0;i<3;i++){
		numch[i]=ch[i+7];
	}
	baseR=numconvert(numch,3);
	PC=reg[baseR];
	return ;
} 

void JSR(char ch[17])			//0100		4
{
	reg[7]=PC;
	if(ch[4]=='1'){
		char numch[11];
		int i;
		short int offset;
		for(i=0;i<11;i++){
			numch[i]=ch[i+5];
		}
		offset=numconvert(numch,11);
		PC=PC+offset;
	}
	else if(ch[4]=='0'){
		char numch[3];
		int i;
		int baseR;
		for(i=0;i<3;i++){
			numch[i]=ch[i+7];
		}
		baseR=numconvert(numch,3);
		PC=reg[baseR];
	} 
	 return ;
} 

void LD(char ch[17])			//0010		2
{
	memnodep Tnode;
	char numch[9];
	short int offset;
	int i;
	int DR;
	for(i=0;i<9;i++){
		numch[i]=ch[i+7];
	}
	offset=numconvert(numch,9);
	for(i=0;i<3;i++){
		numch[i]=ch[i+4];
	}
	DR=numconvert(numch,3);
	MAR=PC+offset;
	Tnode=findloc(MAR);
	strcpy(MDR,Tnode->data);
	reg[DR]=numconvert(MDR,16);
	short int cmp=reg[DR];
	for(i=0;i<3;i++){
		nzp[i]=0;
	}
	if(cmp>0) nzp[2]=1;
	else if(cmp<0) nzp[0]=1;
	else if(cmp==0) nzp[1]=1;
	return ;
	
}
void LDI(char ch[17])			//1010		10
{
	memnodep Tnode;
	char numch[9];
	short int offset;
	int i;
	int DR;
	for(i=0;i<9;i++){
		numch[i]=ch[i+7];
	}
	offset=numconvert(numch,9);
	for(i=0;i<3;i++){
		numch[i]=ch[i+4];
	}
	DR=numconvert(numch,3);
	MAR=PC+offset;
	Tnode=findloc(MAR);
	strcpy(MDR,Tnode->data);
	MAR=numconvert(MDR,16);
	Tnode=findloc(MAR);
	strcpy(MDR,Tnode->data);
	reg[DR]=numconvert(MDR,16);
	short int cmp=reg[DR];
	for(i=0;i<3;i++){
		nzp[i]=0;
	}
	if(cmp>0) nzp[2]=1;
	else if(cmp<0) nzp[0]=1;
	else if(cmp==0) nzp[1]=1;
	
	return ;
}
void LDR(char ch[17])			//0110		6
{
	memnodep Tnode;
	char numch[6];
	int DR,baseR;
	short int offset;
	int i;
	for(i=0;i<3;i++){
		numch[i]=ch[i+4];
	}
	DR=numconvert(numch,3);
	for(i=0;i<3;i++){
		numch[i]=ch[i+7];
	}
	baseR=numconvert(numch,3);
	for(i=0;i<6;i++){
		numch[i]=ch[i+10];
	}
	offset=numconvert(numch,6);
	
	MAR=reg[baseR]+offset;
	Tnode=findloc(MAR);
	strcpy(MDR,Tnode->data);
	reg[DR]=numconvert(MDR,16);
	short int cmp=reg[DR];
	for(i=0;i<3;i++){
		nzp[i]=0;
	}
	if(cmp>0) nzp[2]=1;
	else if(cmp<0) nzp[0]=1;
	else if(cmp==0) nzp[1]=1;
	
	return ;
}

void LEA(char ch[17])			//1110		14
{
	char numch[9];
	int i;
	short int offset;
	int DR;
	for(i=0;i<9;i++){
		numch[i]=ch[i+7];
	}
	offset=numconvert(numch,9);
	
	for(i=0;i<3;i++){
		numch[i]=ch[i+4];
	}
	DR=numconvert(numch,3);
	reg[DR]=PC+offset;
	return ;
}

void ST(char ch[17])			//0011		3
{
	memnodep Tnode;
	char numch[9];
	short int offset;
	int i;
	int SR;
	for(i=0;i<9;i++){
		numch[i]=ch[i+7];
	}
	offset=numconvert(numch,9);
	for(i=0;i<3;i++){
		numch[i]=ch[i+4];
	}
	SR=numconvert(numch,3);
	
	MAR=PC+offset;
	Tnode=findloc(MAR);
	//
	dectobits(reg[SR],MDR);
	strcpy(Tnode->data,MDR);
	
	
	return ;
}
void STI(char ch[17])			//1011		11
{
	memnodep Tnode;
	char numch[9];
	int i,SR;
	short int offset;
	for(i=0;i<9;i++){
		numch[i]=ch[i+7];
	}
	offset= numconvert(numch,9);
	for(i=0;i<3;i++){
		numch[i]=ch[i+4];
	}
	SR=numconvert(numch,3);
	MAR=PC+offset;
	Tnode=findloc(MAR);
	strcpy(MDR,Tnode->data);
	MAR=numconvert(MDR,16);
	Tnode=findloc(MAR);
	dectobits(reg[SR],MDR);
	strcpy(Tnode->data,MDR);
	
	return ; 
}
void STR(char ch[17])			//0111		7
{
	memnodep Tnode;
	char numch[6];
	int SR,baseR,i;
	short int offset;
	for(i=0;i<3;i++){
		numch[i]=ch[i+4];
	}
	SR=numconvert(numch,3);
	for(i=0;i<3;i++){
		numch[i]=ch[i+7];
	}
	baseR=numconvert(numch,3);
	for(i=0;i<6;i++){
		numch[i]=ch[i+10];
	}
	offset=numconvert(numch,6);
	
	MAR=reg[baseR]+offset;
	Tnode=findloc(MAR);
	dectobits(reg[SR],MDR);
	strcpy(Tnode->data,MDR);
	return ;
}

int numconvert(char snum[], int n)
{
	if(n==5||n==6||n==9||n==11||n==16){
		int tempint[16];
		int i;
		int numall=0;
		n=n-1;
		for(i=15;n>=0;i--){
			tempint[i]=snum[n--]-'0';
		}
		if(snum[0]=='1'){
			for(;i>=0;i--){
				tempint[i]=1;
			}
		}
		else if(snum[0]=='0'){
			for(;i>=0;i--){
				tempint[i]=0;
			}
		}
		for(i=15;i>=0;i--){
			numall+=tempint[i]*pow(2,15-i);
		}
		return numall;
	}
	else if(n==4||n==3){
		int tempint[n];
		int i;
		int numall=0;
		for(i=0;i<n;i++){
			tempint[i]=snum[i]-'0';
		}
		for(i=n-1;i>=0;i--){
			numall+=tempint[i]*pow(2,n-1-i);
		}
		return numall;
	}
}
void dectobits(int dec,char bits[17])
{
	bits[16]='\0';
	if(dec>0){
		int temp=dec/2;
		int i=15;
		while(temp!=0){
			bits[i--]=dec%2+'0';
			dec=temp;
			temp=dec/2;
		}
		bits[i--]='1';
		for(;i>=0;i--)
			bits[i]='0';
		bits[16]='\0';
		return ;
	}
	else if(dec<0){
		dec=0-dec;
		int temp=dec/2;
		int i=15;
		while(temp!=0){
			bits[i--]=!(dec%2)+'0';
			dec=temp;
			temp=dec/2;
		}
		bits[i--]='0';
		for(;i>=0;i--)
			bits[i]='1';
		for(i=15;i>=0;i--){
			if(bits[i]=='1')bits[i]='0';
			else if(bits[i]=='0'){
				bits[i]='1';
				break;
			}
		}
		return ;
	}
	if(dec==0){
		int i;
		for(i=0;i<16;i++){
			bits[i]='0';
		}
	}
}

void presult()
{
	int i;
	for(i=0;i<7;i++){
		printf("R%d = x%04hX\n",i,reg[i]);
	}
	printf("R7 = x%04hX",reg[i]);
}

int main()
{
	MEM=newlist();
	scanfI();
	executor();
	presult();
	return 0;
}