# 浙江大学实验报告

课程名称： 操作系统

实验项目名称：RV64环境搭建和内核编译

学生姓名：颜晗 		学号：3200105515

电子邮件地址：3050057413@qq.com

实验日期：2022-10





### 一、实验内容

1. 搭建 Docker 环境

根据[官方文档](https://docs.docker.com/engine/install/ubuntu/) 选择自己喜欢的方法在``ubuntu 22.04`中安装`docker`环境并启动`docker`服务。

```shell
cat oslab.tar | docker import - oslab:2022
### 导入docker镜像命令
### 主要命令为 docker import 部分，‘-’后部分用于为新镜像命名为“oslab”并给予“2022”的tag
### 显然import缺少一个输入的归档文件用于创建镜像
### oslab.tar 即实验提供的归档文件.
### 通过管道连接 cat 和 import 命令，将cat命令的输出（oslab.tar文件内容）变为import的输入
### 同理，我们有另外的命令形式完成任务
docker import - ostest:2022 < oslab.tar
### 如上，使用重定向符号也可完成任务
docker images
### 可查询所建立的镜像
```

![导入](0images\4.1\导入.jpg)

![另一种导入](0images\4.1\另一种导入.jpg)

```shell
docker run --name oslab -it oslab:2022 /bin/bash
### run 命令从镜像中创建容器
### --name oslab 选项，将容器命名为oslab
### -i 交互模式启动容器 -t 为容器分配一个伪输入终端，两个选项通常搭配同时使用
### /bin/bash 容器应保证至少有一个进程在运行，该参数表示容器创建（启动）后执行bash命令
### 即整条命令使用镜像oslab:2022以交互模式创建一个命名为oslab的容器，并在容器中执行/bin/bash命令

docker exec -it oslab /bin/bash 
###参数意义同run命令，在退出容器后重新进入 or 在多个终端进入容器

docker run --name oslab -it -v /home:/home/oslab oslab:2022 /bin/bash
### -v参数使得创建容器时挂载主机的一个目录，如上命令将主机的/home 目录挂载至docker容器中 /home/oslab 目录下，即通过访问docker中的/home/oslab目录我们可以访问到主机的/home目录
### 方便我们在主机使用git后使用docker访问与修改文件
```

![建立容器](0images\4.1\建立容器.jpg)

2. 获取 `Linux `源码和已经编译好的文件系统

进入`/home`目录并克隆实验仓库，内含根文件系统的镜像。

```shell
cd /home #进入/home目录
sudo git clone https://gitee.com/zjusec/os21fall 
#/home目录下普通用户无权限建立新目录，需要超级用户权限

```

![git](0images\4.2\git.jpg)

在`/home/os21fall/src/lab0`目录下下载`linux`源码。

```shell
sudo apt install wget   ### 安装下载工具
sudo wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.19.8.tar.xz
### 国内备用下载地址
sudo wget http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v5.x/linux-5.19.8.tar.gz 

tar -zxvf linux-5.19.8.tar.gz
### 下载的源文件为压缩包，需要使用命令解压缩
```

![安装wget](0images\4.2\安装wget.jpg)

![下载源码](0images\4.2\下载源码.jpg)

![解压](0images\4.2\解压.jpg)

3. 编译`linux`内核

```shell
docker exec -it oslab /bin/bash
### 接下来的步骤在docker中执行，需要进入docker

export PATH=$PATH:/opt/riscv/bin
### 设置环境变量，使得后面的编译命令可以不必重复地址
make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- defconfig   
### 生成配置
make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- -j$(nproc)
### 编译
```

![编译配置](0images\4.3\编译配置.jpg)

编译后的内核目录

![Snipaste_2022-10-06_21-29-28](0images\4.3\Snipaste_2022-10-06_21-29-28.jpg)

4. 使用`QEMU`运行内核

```shell
cd  /home/os21fall/src/lab0/
### 内含linux源代码目录
qemu-system-riscv64 -nographic -machine virt -kernel linux-5.19.8/arch/riscv/boot/Image \
-device virtio-blk-device,drive=hd0 -append"root=/dev/vda ro console=ttyS0" \
-bios default -drivefile=rootfs.img,format=raw,id=hd0
```

![运行](0images\4.4\运行.jpg)

![Snipaste_2022-09-19_15-49-08](0images\4.4\Snipaste_2022-09-19_15-49-08.jpg)

5. 使用`gdb`调试内核

```shell
### 同时开启两个终端并同时运行docker，分别启动qemu与gdb
### Terminal 1
cd /home/os21fall/src/lab0
qemu-system-riscv64 -nographic -machine virt -kernel linux-5.19.8/arch/riscv/boot/Image \
-device virtio-blk-device,drive=hd0 -append"root=/dev/vda ro console=ttyS0" \
-bios default -drivefile=rootfs.img,format=raw,id=hd0 -S -s
### 最后添加的-S -s参数用于在启动后qemu不立即运行guest，而等待主机gdb发起连接，可以方便进行调试

### Terminal 2
export PATH=$PATH:/opt/riscv/bin
riscv64-unknown-linux-gnu-gdb /home/oslab/os21fall/src/lab0/linux-5.19.8/vmlinux

### 可能出现Reading symbols from vmlinux...(No debugging symbols found in vmlinux)信息，需要在内核Makefile的KBUILD_CFLAGS上添加-g选项，然后重新编译内核，继续运行上述命令行启动gdb开始调试。
### 该信息并不算警告或错误，可能会淹没在gdb的启动信息中，要仔细查看，否则无调试信息
```

启动并连接的图示。

![1-启动](0images\4.5\1-启动.jpg)



**部分指令执行**

![2-](0images\4.5\2-.jpg)

![3](0images\4.5\3.jpg)

![4](0images\4.5\4.jpg)

![5](0images\4.5\5.jpg)



### 二、思考题

1. 使用`riscv64-unknown-elf-gcc`编译单个`.c`文件
2. 使用`riscv64-unknown-elf-objdump`反汇编`1`中得到的编译产物。

>* 简单编写一个c文件
>
>![1](0images\4.6\1.jpg)
>
>* 编译与反汇编
>
>![2](0images\4.6\2.jpg)
>
>![3](0images\4.6\3.jpg)



3. 

```shell
layout asm # 查看汇编代码
b *0x80000000 #在0x80000000处下断点
i b #查看所有已下断点
b *0x80200000 #在0x80200000处下断点
d 1(需删断点对应的编号) # 删除编号为1的断点，此处为0x80000000
c # 继续运行至触发0x80200000
n 1 # 单步调试一次
```

![4](0images\4.6\4.jpg)

退出QEMU

![5](0images\4.6\5.jpg)

4. 使用`make`工具清除`linux`的构建产物

![6](0images\4.6\6.jpg)

![7](0images\4.6\7.jpg)



5. `vmlinux`和`Image`的关系和区别

>两者都是`linux`内核映像，
>
>`vmlinux`是编译出来的最原始的未压缩的文件，为`ELF`格式文件，该映像可用于定位内核问题，但不能直接引导Linux系统启动，可用于`debug`。
>
>`Image`是使用`objcopy`处理`vmlinux`丢弃多余信息后的完全的二进制文件，未经过压缩，可以直接引导`Linux`内核启动。
>
>两者的关系在于同为`Linux`内核映像文件，`Image`为`vmlinux`处理后的产物；
>
>区别为两者文件格式不同，`Image`可用于`Linux`系统启动，`vmlinux`不能。



### 三、讨论、心得

本次实验的指导非常详细，基本按照命令一步步执行下去即可，`gdb`调试部分看给出的参考书也可有一个基本的了解。也增强了安装和使用环境的能力。但是作为导引除了调试技术实在看不出来和后面的实验的关联部分，给出的实验资料也比较杂，让人依旧摸不着头脑。
