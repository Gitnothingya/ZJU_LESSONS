## 整体架构

> ```mermaid
> graph LR
> 手机 --蓝牙--> ESP32
> ESP32 --蓝牙--> 手机
> 
> subgraph 结点 
> ESP32 --串口--> STM32
> STM32 --- RxLora
> STM32 --- TxLora
> STM32 --串口--> ESP32
> end
> 
> TxLora -.- 远端结点
> RxLora -.- 远端结点
> ```

如上为我们项目的硬件设备沟通模型。

我们每个结点都由一块`ESP32`开发板， 一块`STM32F103C8T6`开发板以及两个`SX1278`模块(分别用来发送和接受)。手机可通过蓝牙与`ESP32`连接来发送和接受信息，而每个结点之间可通过Lora模块交互信息。

* 我们的结点大致可分为服务节点和中间结点。
  * 服务节点即包含有控制设备（如`DHT11`）的结点，可以直接获取相关信息并控制设备状态。每个结点仅控制一个设备。
  * 中间结点即不包含控制设备，仅有转发消息功能的结点。

下面以一次温湿度的获取为例阐述控制原理。

1. 手机进入APP，点击`DHT11`设备进入界面，自动向连接的结点发送请求信息。
2. `ESP32`获取信息，如果请求的设备就在本结点，直接向手机发送温湿度信息。如果在远端结点，则通过串口向本地`STM32`转发请求。
3. 本地`STM32`获取请求后，将相关信息封装并发送出去。

3. 远端`STM32`获取请求后，如果自身是目标机器，解析出信息后通过串口发送给`ESP32`，否则按照规则进行转发。
4. 远端`ESP32`接收到请求，获取温湿度信息后将格式化的信息发送给`STM32`。
5. `STM32`将信息封装好发送给请求的结点。
6. 本地`STM32`获取信息后再通过串口发送给`ESP32`.
7. `ESP32`将格式化信息发送给手机。手机获取信息并显示。





## ESP32 控制

`ESP32`通过`micropython`进行控制，通过其模块可以方便地控制各个设备并和通过蓝牙和手机沟通。

以下为我们进行蓝牙控制的类。实例化该蓝牙类后，会有一个新开的线程专门用于接收手机信息。要想发送信息我们只需要在主线程使用`send()`函数即可。

```python
# 蓝牙控制类
class ESP32_BLE():
    def __init__(self, name): #初始化类数据
        self.led =  Pin(2, Pin.OUT) # 通过LED显示蓝牙是否连接
        self.timer1 = Timer(0)      # 未连接时需要持续广播
        self.name = name			# 蓝牙名字
        self.ble = bluetooth.BLE()	# 以下为micropython 蓝牙控制接口的配置
        self.ble.active(True)		 
        self.ble.config(gap_name=name)
        self.disconnected()
        self.ble.irq(self.ble_irq) # 中断控制
        self.register()  # 注册蓝牙服务信息
        self.advertiser() # 广播连接信号

    def connected(self):
        self.led.value(1)
        self.timer1.deinit()

    def disconnected(self):
        self.timer1.init(period=100, mode=Timer.PERIODIC, callback=lambda t: self.led.value(0))
        

    def ble_irq(self, event, data):
        global BLE_MSG
        if event == 1: #_IRQ_CENTRAL_CONNECT 手机链接了此设备
            self.connected()
        elif event == 2: #_IRQ_CENTRAL_DISCONNECT 手机断开此设备
            self.advertiser()
            self.disconnected()
        elif event == 3: #_IRQ_GATTS_WRITE 手机发送了数据 
            buffer = self.ble.gatts_read(self.rx)
            BLE_MSG = buffer.decode('UTF-8').strip() # 将信息存入变量
            
            
    def register(self):        # 注册蓝牙服务uuid
        service_uuid = '6E400001-B5A3-F393-E0A9-E50E24DCCA9E'
        reader_uuid = '6E400002-B5A3-F393-E0A9-E50E24DCCA9E'
        sender_uuid = '6E400003-B5A3-F393-E0A9-E50E24DCCA9E'

        services = (
            (
                bluetooth.UUID(service_uuid), 
                (
                    (bluetooth.UUID(sender_uuid), bluetooth.FLAG_READ | bluetooth.FLAG_NOTIFY), 
                    (bluetooth.UUID(reader_uuid), bluetooth.FLAG_WRITE),
                )
            ), 
        )

        ((self.tx, self.rx,), ) = self.ble.gatts_register_services(services)

    def send(self, data): # 向手机发送信息
        self.ble.gatts_write(self.tx, data + '\n')

    def advertiser(self): 
        name = bytes(self.name, 'UTF-8')
        adv_data = bytearray(b'\x02\x01\x02') + bytearray((len(name) + 1, 0x09)) + name
        self.ble.gap_advertise(100, adv_data)
        print(adv_data)
        print("\r\n")
```

如下为串口控制的接口。

```python
uart = machine.UART(1, baudrate=115200, tx = 10, rx = 9) # 创建串口对象
uart.any() # 串口是否接收到信息
uart.read() # 串口接收信息读取
uart.write() # 串口发送信息
```









## STM32-SX1278 控制

同时开启`SPI1`和`SPI2`分别控制发送模块和接收模块。一个专门用来发送，另一个专门用来接收。实现两个结点之间的全双工通信。

```C
/**************************发送模块********************************/
SX1278_hw_t Txsx1278_hw = {
  {TxSX_RST_Pin, TxSX_RST_GPIO_Port},     // rst
  {TxSX_D0_Pin, TxSX_D0_GPIO_Port},       // dio0
  {TxSX_NSS_Pin, TxSX_NSS_GPIO_Port},     // nss
  &hspi1
};
SX1278_t Txsx1278 = {
  &Txsx1278_hw,         // SX1278_hw_t *hw;
};

/**************************接收模块********************************/
SX1278_hw_t Rxsx1278_hw = {
  {RxSX_RST_Pin, RxSX_RST_GPIO_Port},     // rst
  {RxSX_D0_Pin, RxSX_D0_GPIO_Port},       // dio0
  {RxSX_NSS_Pin, RxSX_NSS_GPIO_Port},     // nss
  &hspi2
};
SX1278_t Rxsx1278 = {
  &Rxsx1278_hw,         // SX1278_hw_t *hw;
};

//初始化两个模块
SX1278_init(&Rxsx1278, 434000000, SX1278_POWER_11DBM, SX1278_LORA_SF_7,
          SX1278_LORA_BW_125KHZ, SX1278_LORA_CR_4_5, SX1278_LORA_CRC_EN, 10);
SX1278_init(&Txsx1278, 434000000, SX1278_POWER_11DBM, SX1278_LORA_SF_7,
          SX1278_LORA_BW_125KHZ, SX1278_LORA_CR_4_5, SX1278_LORA_CRC_EN, 10);
```

物理层仅负责无脑的发送和接收，不对网络进行控制，上层完全调用驱动的函数。
