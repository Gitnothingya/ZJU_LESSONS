#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  programs programs/02-Learning-by-Example
#   programs/03-Problem-Solving programs/04-Statement-Forms
#   programs/05-Functions programs/06-Algorithms programs/07-Graphics
#   programs/08-Random-Numbers programs/09-Strings
#   programs/10-Modular-Development programs/11-Arrays
#   programs/12-Sorting programs/13-Pointers
#   programs/14-Strings-Revisited programs/15-Text-Files
#   programs/16-Records programs/17-Looking-Ahead
#   programs/02-Learning-by-Example/Makefile
#   programs/02-Learning-by-Example/add2.c
#   programs/02-Learning-by-Example/add2f.c
#   programs/02-Learning-by-Example/ave2f.c
#   programs/02-Learning-by-Example/cmtofeet.c
#   programs/02-Learning-by-Example/greeting.c
#   programs/02-Learning-by-Example/hello.c
#   programs/02-Learning-by-Example/inchtocm.c
#   programs/03-Problem-Solving/Makefile
#   programs/03-Problem-Solving/add10.c
#   programs/03-Problem-Solving/addlist.c
#   programs/03-Problem-Solving/balance1.c
#   programs/03-Problem-Solving/balance2.c
#   programs/03-Problem-Solving/balance3.c
#   programs/03-Problem-Solving/balance4.c
#   programs/03-Problem-Solving/count10.c
#   programs/03-Problem-Solving/roses.c
#   programs/04-Statement-Forms/Makefile
#   programs/04-Statement-Forms/addlist.c
#   programs/04-Statement-Forms/cardrank.c
#   programs/04-Statement-Forms/digitsum.c
#   programs/04-Statement-Forms/leapyear.c
#   programs/04-Statement-Forms/liftoff.c
#   programs/04-Statement-Forms/oddeven.c
#   programs/04-Statement-Forms/signtest.c
#   programs/04-Statement-Forms/timestab.c
#   programs/05-Functions/Makefile programs/05-Functions/c2ftable.c
#   programs/05-Functions/calendar.c programs/05-Functions/combine.c
#   programs/05-Functions/fact.c programs/05-Functions/gameloop.c
#   programs/05-Functions/iseven.c programs/06-Algorithms/Makefile
#   programs/06-Algorithms/euclid.c programs/06-Algorithms/gcd.c
#   programs/06-Algorithms/nsqrt.c programs/06-Algorithms/primes1.c
#   programs/06-Algorithms/primes2.c programs/06-Algorithms/primes3.c
#   programs/06-Algorithms/tsqrt.c programs/06-Algorithms/zeno.c
#   programs/07-Graphics/Makefile programs/07-Graphics/arc1.c
#   programs/07-Graphics/arc2.c programs/07-Graphics/drawbox.c
#   programs/07-Graphics/drawcbox.c programs/07-Graphics/drawcirc.c
#   programs/07-Graphics/house.c programs/07-Graphics/oneline.c
#   programs/08-Random-Numbers/Makefile
#   programs/08-Random-Numbers/cointest.c
#   programs/08-Random-Numbers/craps.c
#   programs/08-Random-Numbers/dicetest.c
#   programs/08-Random-Numbers/random.c
#   programs/08-Random-Numbers/random.h
#   programs/08-Random-Numbers/randtest.c programs/09-Strings/Makefile
#   programs/09-Strings/acronym.c programs/09-Strings/addlist.c
#   programs/09-Strings/lastchar.c programs/09-Strings/linelen.c
#   programs/09-Strings/ncopies.c programs/09-Strings/protect.c
#   programs/09-Strings/repfirst.c programs/09-Strings/reverse.c
#   programs/09-Strings/secondh.c
#   programs/10-Modular-Development/Makefile
#   programs/10-Modular-Development/piglatin.c
#   programs/10-Modular-Development/scanner.c
#   programs/10-Modular-Development/scanner.h
#   programs/11-Arrays/Makefile programs/11-Arrays/countlet.c
#   programs/11-Arrays/gymjudge.c programs/11-Arrays/reverse.c
#   programs/11-Arrays/testrev.c programs/12-Sorting/Makefile
#   programs/12-Sorting/findcoin.c programs/12-Sorting/mileage.c
#   programs/12-Sorting/mileage2.c programs/12-Sorting/sort.c
#   programs/12-Sorting/sort.h programs/12-Sorting/testsort.c
#   programs/13-Pointers/Makefile programs/13-Pointers/hours.c
#   programs/13-Pointers/sort.c programs/13-Pointers/sort.h
#   programs/13-Pointers/testsort.c
#   programs/14-Strings-Revisited/Makefile
#   programs/14-Strings-Revisited/invert.c
#   programs/15-Text-Files/Makefile programs/15-Text-Files/copyfile.c
#   programs/15-Text-Files/elements.c
#   programs/15-Text-Files/elements.dat
#   programs/15-Text-Files/hamlet.txt
#   programs/15-Text-Files/juliet.txt
#   programs/15-Text-Files/linecopy.c programs/15-Text-Files/remcom.c
#   programs/15-Text-Files/showfile.c programs/15-Text-Files/ucfile.c
#   programs/15-Text-Files/witches.txt programs/16-Records/Makefile
#   programs/16-Records/advent.dat programs/16-Records/cs.dat
#   programs/16-Records/empdb.c programs/16-Records/employee.c
#   programs/16-Records/point.c programs/16-Records/teach.c
#   programs/17-Looking-Ahead/Makefile
#   programs/17-Looking-Ahead/fact.c
#   programs/17-Looking-Ahead/permute.c
#   programs/17-Looking-Ahead/power.c
#   programs/17-Looking-Ahead/qtest.c
#   programs/17-Looking-Ahead/queue.c
#   programs/17-Looking-Ahead/queue.h programs/17-Looking-Ahead/sort.c
#   programs/17-Looking-Ahead/sort.h
#   programs/17-Looking-Ahead/testsort.c
# Wrapped by eroberts@Eeyore.Stanford.EDU on Fri Oct 21 13:36:56 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'programs' ; then
    echo shar: Creating directory \"'programs'\"
    mkdir 'programs'
fi
if test ! -d 'programs/02-Learning-by-Example' ; then
    echo shar: Creating directory \"'programs/02-Learning-by-Example'\"
    mkdir 'programs/02-Learning-by-Example'
fi
if test ! -d 'programs/03-Problem-Solving' ; then
    echo shar: Creating directory \"'programs/03-Problem-Solving'\"
    mkdir 'programs/03-Problem-Solving'
fi
if test ! -d 'programs/04-Statement-Forms' ; then
    echo shar: Creating directory \"'programs/04-Statement-Forms'\"
    mkdir 'programs/04-Statement-Forms'
fi
if test ! -d 'programs/05-Functions' ; then
    echo shar: Creating directory \"'programs/05-Functions'\"
    mkdir 'programs/05-Functions'
fi
if test ! -d 'programs/06-Algorithms' ; then
    echo shar: Creating directory \"'programs/06-Algorithms'\"
    mkdir 'programs/06-Algorithms'
fi
if test ! -d 'programs/07-Graphics' ; then
    echo shar: Creating directory \"'programs/07-Graphics'\"
    mkdir 'programs/07-Graphics'
fi
if test ! -d 'programs/08-Random-Numbers' ; then
    echo shar: Creating directory \"'programs/08-Random-Numbers'\"
    mkdir 'programs/08-Random-Numbers'
fi
if test ! -d 'programs/09-Strings' ; then
    echo shar: Creating directory \"'programs/09-Strings'\"
    mkdir 'programs/09-Strings'
fi
if test ! -d 'programs/10-Modular-Development' ; then
    echo shar: Creating directory \"'programs/10-Modular-Development'\"
    mkdir 'programs/10-Modular-Development'
fi
if test ! -d 'programs/11-Arrays' ; then
    echo shar: Creating directory \"'programs/11-Arrays'\"
    mkdir 'programs/11-Arrays'
fi
if test ! -d 'programs/12-Sorting' ; then
    echo shar: Creating directory \"'programs/12-Sorting'\"
    mkdir 'programs/12-Sorting'
fi
if test ! -d 'programs/13-Pointers' ; then
    echo shar: Creating directory \"'programs/13-Pointers'\"
    mkdir 'programs/13-Pointers'
fi
if test ! -d 'programs/14-Strings-Revisited' ; then
    echo shar: Creating directory \"'programs/14-Strings-Revisited'\"
    mkdir 'programs/14-Strings-Revisited'
fi
if test ! -d 'programs/15-Text-Files' ; then
    echo shar: Creating directory \"'programs/15-Text-Files'\"
    mkdir 'programs/15-Text-Files'
fi
if test ! -d 'programs/16-Records' ; then
    echo shar: Creating directory \"'programs/16-Records'\"
    mkdir 'programs/16-Records'
fi
if test ! -d 'programs/17-Looking-Ahead' ; then
    echo shar: Creating directory \"'programs/17-Looking-Ahead'\"
    mkdir 'programs/17-Looking-Ahead'
fi
if test -f 'programs/02-Learning-by-Example/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/02-Learning-by-Example/Makefile'\"
else
echo shar: Extracting \"'programs/02-Learning-by-Example/Makefile'\" \(1698 characters\)
sed "s/^X//" >'programs/02-Learning-by-Example/Makefile' <<'END_OF_FILE'
X# Makefile for cbook/02-Learning-by-Example/programs
X# Created by the ExportAll facility
X# ***************************************************************
X
XPROGRAMS = \
X    hello \
X    add2 \
X    add2f \
X    greeting \
X    inchtocm \
X    ave2f \
X    cmtofeet 
X
X# ***************************************************************
X# Parameters to control Makefile operation
X# Note that the gccx command script must be defined
X
XCC = gccx
XCFLAGS = 
X
X# ***************************************************************
X# Entry to bring the package up to date
X
Xall: $(PROGRAMS)
X
X# ***************************************************************
X# Standard entries to remove files from the directories
X#    tidy    -- eliminate unwanted files
X#    scratch -- delete derived files in preparation for rebuild
X
Xtidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
Xscratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
X# ***************************************************************
X# C compilations
X
Xhello.o: hello.c
X	$(CC) $(CFLAGS) -c hello.c
X
Xadd2.o: add2.c
X	$(CC) $(CFLAGS) -c add2.c
X
Xadd2f.o: add2f.c
X	$(CC) $(CFLAGS) -c add2f.c
X
Xgreeting.o: greeting.c
X	$(CC) $(CFLAGS) -c greeting.c
X
Xinchtocm.o: inchtocm.c
X	$(CC) $(CFLAGS) -c inchtocm.c
X
Xave2f.o: ave2f.c
X	$(CC) $(CFLAGS) -c ave2f.c
X
Xcmtofeet.o: cmtofeet.c
X	$(CC) $(CFLAGS) -c cmtofeet.c
X
X
Xhello: hello.o
X	$(CC) $(CFLAGS) -o hello hello.o
X
Xadd2: add2.o
X	$(CC) $(CFLAGS) -o add2 add2.o
X
Xadd2f: add2f.o
X	$(CC) $(CFLAGS) -o add2f add2f.o
X
Xgreeting: greeting.o
X	$(CC) $(CFLAGS) -o greeting greeting.o
X
Xinchtocm: inchtocm.o
X	$(CC) $(CFLAGS) -o inchtocm inchtocm.o
X
Xave2f: ave2f.o
X	$(CC) $(CFLAGS) -o ave2f ave2f.o
X
Xcmtofeet: cmtofeet.o
X	$(CC) $(CFLAGS) -o cmtofeet cmtofeet.o
END_OF_FILE
if test 1698 -ne `wc -c <'programs/02-Learning-by-Example/Makefile'`; then
    echo shar: \"'programs/02-Learning-by-Example/Makefile'\" unpacked with wrong size!
fi
# end of 'programs/02-Learning-by-Example/Makefile'
fi
if test -f 'programs/02-Learning-by-Example/add2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/02-Learning-by-Example/add2.c'\"
else
echo shar: Extracting \"'programs/02-Learning-by-Example/add2.c'\" \(430 characters\)
sed "s/^X//" >'programs/02-Learning-by-Example/add2.c' <<'END_OF_FILE'
X/*
X * File: add2.c
X * ------------
X * This program reads in two numbers, adds them together,
X * and prints their sum.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
Xmain()
X{
X    int n1, n2, total;
X
X    printf("This program adds two numbers.\n");
X    printf("1st number? ");
X    n1 = GetInteger();
X    printf("2nd number? ");
X    n2 = GetInteger();
X    total = n1 + n2;
X    printf("The total is %d.\n", total);
X}
END_OF_FILE
if test 430 -ne `wc -c <'programs/02-Learning-by-Example/add2.c'`; then
    echo shar: \"'programs/02-Learning-by-Example/add2.c'\" unpacked with wrong size!
fi
# end of 'programs/02-Learning-by-Example/add2.c'
fi
if test -f 'programs/02-Learning-by-Example/add2f.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/02-Learning-by-Example/add2f.c'\"
else
echo shar: Extracting \"'programs/02-Learning-by-Example/add2f.c'\" \(458 characters\)
sed "s/^X//" >'programs/02-Learning-by-Example/add2f.c' <<'END_OF_FILE'
X/*
X * File: add2f.c
X * -------------
X * This program reads in two floating-point numbers, adds them
X * together, and prints their sum.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
Xmain()
X{
X    double n1, n2, total;
X
X    printf("This program adds two floating-point numbers.\n");
X    printf("1st number? ");
X    n1 = GetReal();
X    printf("2nd number? ");
X    n2 = GetReal();
X    total = n1 + n2;
X    printf("The total is %g\n", total);
X}
END_OF_FILE
if test 458 -ne `wc -c <'programs/02-Learning-by-Example/add2f.c'`; then
    echo shar: \"'programs/02-Learning-by-Example/add2f.c'\" unpacked with wrong size!
fi
# end of 'programs/02-Learning-by-Example/add2f.c'
fi
if test -f 'programs/02-Learning-by-Example/ave2f.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/02-Learning-by-Example/ave2f.c'\"
else
echo shar: Extracting \"'programs/02-Learning-by-Example/ave2f.c'\" \(461 characters\)
sed "s/^X//" >'programs/02-Learning-by-Example/ave2f.c' <<'END_OF_FILE'
X/*
X * File: ave2f.c
X * -------------
X * This program reads in two floating-point numbers and
X * computes their average.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
Xmain()
X{
X    double n1, n2, average;
X
X    printf("This program averages two floating-point numbers.\n");
X    printf("1st number? ");
X    n1 = GetReal();
X    printf("2nd number? ");
X    n2 = GetReal();
X    average = (n1 + n2) / 2;
X    printf("The average is %g\n", average);
X}
END_OF_FILE
if test 461 -ne `wc -c <'programs/02-Learning-by-Example/ave2f.c'`; then
    echo shar: \"'programs/02-Learning-by-Example/ave2f.c'\" unpacked with wrong size!
fi
# end of 'programs/02-Learning-by-Example/ave2f.c'
fi
if test -f 'programs/02-Learning-by-Example/cmtofeet.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/02-Learning-by-Example/cmtofeet.c'\"
else
echo shar: Extracting \"'programs/02-Learning-by-Example/cmtofeet.c'\" \(565 characters\)
sed "s/^X//" >'programs/02-Learning-by-Example/cmtofeet.c' <<'END_OF_FILE'
X/*
X * File: cmtofeet.c
X * ----------------
X * This program reads in a length given in centimeters and converts
X * it to its English equivalent in feet and inches.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
Xmain()
X{
X    double totalInches, cm, inch;
X    int feet;
X
X    printf("This program converts centimeters to feet and inches.\n");
X    printf("Length in centimeters? ");
X    cm = GetReal();
X    totalInches = cm / 2.54;
X    feet = totalInches / 12;
X    inch = totalInches - feet * 12;
X    printf("%g cm = %d ft %g in\n", cm, feet, inch);
X}
END_OF_FILE
if test 565 -ne `wc -c <'programs/02-Learning-by-Example/cmtofeet.c'`; then
    echo shar: \"'programs/02-Learning-by-Example/cmtofeet.c'\" unpacked with wrong size!
fi
# end of 'programs/02-Learning-by-Example/cmtofeet.c'
fi
if test -f 'programs/02-Learning-by-Example/greeting.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/02-Learning-by-Example/greeting.c'\"
else
echo shar: Extracting \"'programs/02-Learning-by-Example/greeting.c'\" \(364 characters\)
sed "s/^X//" >'programs/02-Learning-by-Example/greeting.c' <<'END_OF_FILE'
X/*
X * File: greeting.c
X * ----------------
X * This program prints a more personal greeting than did
X * the original "Hello, world." program by reading in the
X * name of the user.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
Xmain()
X{
X    string user;
X
X    printf("What is your name? ");
X    user = GetLine();
X    printf("Hello, %s.\n", user);
X}
END_OF_FILE
if test 364 -ne `wc -c <'programs/02-Learning-by-Example/greeting.c'`; then
    echo shar: \"'programs/02-Learning-by-Example/greeting.c'\" unpacked with wrong size!
fi
# end of 'programs/02-Learning-by-Example/greeting.c'
fi
if test -f 'programs/02-Learning-by-Example/hello.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/02-Learning-by-Example/hello.c'\"
else
echo shar: Extracting \"'programs/02-Learning-by-Example/hello.c'\" \(323 characters\)
sed "s/^X//" >'programs/02-Learning-by-Example/hello.c' <<'END_OF_FILE'
X/*
X * File: hello.c
X * -------------
X * This program prints the message "Hello, world."
X * on the screen.  The program is taken from the
X * classic C reference text "The C Programming
X * Language" by Brian Kernighan and Dennis Ritchie.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X
Xmain()
X{
X    printf("Hello, world.\n");
X}
END_OF_FILE
if test 323 -ne `wc -c <'programs/02-Learning-by-Example/hello.c'`; then
    echo shar: \"'programs/02-Learning-by-Example/hello.c'\" unpacked with wrong size!
fi
# end of 'programs/02-Learning-by-Example/hello.c'
fi
if test -f 'programs/02-Learning-by-Example/inchtocm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/02-Learning-by-Example/inchtocm.c'\"
else
echo shar: Extracting \"'programs/02-Learning-by-Example/inchtocm.c'\" \(432 characters\)
sed "s/^X//" >'programs/02-Learning-by-Example/inchtocm.c' <<'END_OF_FILE'
X/*
X * File: inchtocm.c
X * ----------------
X * This program reads in a length given in inches and converts it
X * to its metric equivalent in centimeters.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
Xmain()
X{
X    double inch, cm;
X
X    printf("This program converts inches to centimeters.\n");
X    printf("Length in inches? ");
X    inch = GetReal();
X    cm = inch * 2.54;
X    printf("%g in = %g cm\n", inch, cm);
X}
END_OF_FILE
if test 432 -ne `wc -c <'programs/02-Learning-by-Example/inchtocm.c'`; then
    echo shar: \"'programs/02-Learning-by-Example/inchtocm.c'\" unpacked with wrong size!
fi
# end of 'programs/02-Learning-by-Example/inchtocm.c'
fi
if test -f 'programs/03-Problem-Solving/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/03-Problem-Solving/Makefile'\"
else
echo shar: Extracting \"'programs/03-Problem-Solving/Makefile'\" \(1866 characters\)
sed "s/^X//" >'programs/03-Problem-Solving/Makefile' <<'END_OF_FILE'
X# Makefile for cbook/03-Problem-Solving/programs
X# Created by the ExportAll facility
X# ***************************************************************
X
XPROGRAMS = \
X    count10 \
X    add10 \
X    addlist \
X    balance1 \
X    balance2 \
X    balance3 \
X    balance4 \
X    roses 
X
X# ***************************************************************
X# Parameters to control Makefile operation
X# Note that the gccx command script must be defined
X
XCC = gccx
XCFLAGS = 
X
X# ***************************************************************
X# Entry to bring the package up to date
X
Xall: $(PROGRAMS)
X
X# ***************************************************************
X# Standard entries to remove files from the directories
X#    tidy    -- eliminate unwanted files
X#    scratch -- delete derived files in preparation for rebuild
X
Xtidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
Xscratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
X# ***************************************************************
X# C compilations
X
Xcount10.o: count10.c
X	$(CC) $(CFLAGS) -c count10.c
X
Xadd10.o: add10.c
X	$(CC) $(CFLAGS) -c add10.c
X
Xaddlist.o: addlist.c
X	$(CC) $(CFLAGS) -c addlist.c
X
Xbalance1.o: balance1.c
X	$(CC) $(CFLAGS) -c balance1.c
X
Xbalance2.o: balance2.c
X	$(CC) $(CFLAGS) -c balance2.c
X
Xbalance3.o: balance3.c
X	$(CC) $(CFLAGS) -c balance3.c
X
Xbalance4.o: balance4.c
X	$(CC) $(CFLAGS) -c balance4.c
X
Xroses.o: roses.c
X	$(CC) $(CFLAGS) -c roses.c
X
X
Xcount10: count10.o
X	$(CC) $(CFLAGS) -o count10 count10.o
X
Xadd10: add10.o
X	$(CC) $(CFLAGS) -o add10 add10.o
X
Xaddlist: addlist.o
X	$(CC) $(CFLAGS) -o addlist addlist.o
X
Xbalance1: balance1.o
X	$(CC) $(CFLAGS) -o balance1 balance1.o
X
Xbalance2: balance2.o
X	$(CC) $(CFLAGS) -o balance2 balance2.o
X
Xbalance3: balance3.o
X	$(CC) $(CFLAGS) -o balance3 balance3.o
X
Xbalance4: balance4.o
X	$(CC) $(CFLAGS) -o balance4 balance4.o
X
Xroses: roses.o
X	$(CC) $(CFLAGS) -o roses roses.o
END_OF_FILE
if test 1866 -ne `wc -c <'programs/03-Problem-Solving/Makefile'`; then
    echo shar: \"'programs/03-Problem-Solving/Makefile'\" unpacked with wrong size!
fi
# end of 'programs/03-Problem-Solving/Makefile'
fi
if test -f 'programs/03-Problem-Solving/add10.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/03-Problem-Solving/add10.c'\"
else
echo shar: Extracting \"'programs/03-Problem-Solving/add10.c'\" \(573 characters\)
sed "s/^X//" >'programs/03-Problem-Solving/add10.c' <<'END_OF_FILE'
X/*
X * File: add10.c
X * -------------
X * This program adds a list of ten numbers, printing
X * the total at the end.  Instead of reading the numbers
X * into separate variables, this program reads in each
X * number and adds it to a running total.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
Xmain()
X{
X    int i, value, total;
X
X    printf("This program adds a list of ten numbers.\n");
X    total = 0;
X    for (i = 0; i < 10; i++) {
X        printf(" ? ");
X        value = GetInteger();
X        total += value;
X    }
X    printf("The total is %d\n", total);
X}
END_OF_FILE
if test 573 -ne `wc -c <'programs/03-Problem-Solving/add10.c'`; then
    echo shar: \"'programs/03-Problem-Solving/add10.c'\" unpacked with wrong size!
fi
# end of 'programs/03-Problem-Solving/add10.c'
fi
if test -f 'programs/03-Problem-Solving/addlist.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/03-Problem-Solving/addlist.c'\"
else
echo shar: Extracting \"'programs/03-Problem-Solving/addlist.c'\" \(541 characters\)
sed "s/^X//" >'programs/03-Problem-Solving/addlist.c' <<'END_OF_FILE'
X/*
X * File: addlist.c
X * ---------------
X * This program adds a list of numbers.  The end of the
X * input is indicated by entering 0 as a sentinel value.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
Xmain()
X{
X    int value, total;
X
X    printf("This program adds a list of numbers.\n");
X    printf("Signal end of list with a 0.\n");
X    total = 0;
X    while (TRUE) {
X        printf(" ? ");
X        value = GetInteger();
X        if (value == 0) break;
X        total += value;
X    }
X    printf("The total is %d\n", total);
X}
END_OF_FILE
if test 541 -ne `wc -c <'programs/03-Problem-Solving/addlist.c'`; then
    echo shar: \"'programs/03-Problem-Solving/addlist.c'\" unpacked with wrong size!
fi
# end of 'programs/03-Problem-Solving/addlist.c'
fi
if test -f 'programs/03-Problem-Solving/balance1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/03-Problem-Solving/balance1.c'\"
else
echo shar: Extracting \"'programs/03-Problem-Solving/balance1.c'\" \(972 characters\)
sed "s/^X//" >'programs/03-Problem-Solving/balance1.c' <<'END_OF_FILE'
X/*
X * File: balance1.c
X * ----------------
X * This file contains the first version of a program to
X * balance a checkbook.  The user enters checks and deposits
X * throughout the month (checks are entered as negative
X * numbers).  The end of the input is indicated by entering
X * 0 as a sentinel value.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
Xmain()
X{
X    double entry, balance;
X
X    printf("This program helps you balance your checkbook.\n");
X    printf("Enter each check and deposit during the month.\n");
X    printf("To indicate a check, use a minus sign.\n");
X    printf("Signal the end of the month with a 0 value.\n");
X    printf("Enter the initial balance: ");
X    balance = GetReal();
X    while (TRUE) {
X        printf("Enter check (-) or deposit: ");
X        entry = GetReal();
X        if (entry == 0) break;
X        balance += entry;
X        printf("Current balance = %g\n", balance);
X    }
X    printf("Final balance = %g\n", balance);
X}
END_OF_FILE
if test 972 -ne `wc -c <'programs/03-Problem-Solving/balance1.c'`; then
    echo shar: \"'programs/03-Problem-Solving/balance1.c'\" unpacked with wrong size!
fi
# end of 'programs/03-Problem-Solving/balance1.c'
fi
if test -f 'programs/03-Problem-Solving/balance2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/03-Problem-Solving/balance2.c'\"
else
echo shar: Extracting \"'programs/03-Problem-Solving/balance2.c'\" \(926 characters\)
sed "s/^X//" >'programs/03-Problem-Solving/balance2.c' <<'END_OF_FILE'
X/*
X * File: balance2.c
X * ----------------
X * This file contains a buggy second attempt at a program to
X * balance a checkbook.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
Xmain()
X{
X    double entry, balance;
X
X    printf("This program helps you balance your checkbook.\n");
X    printf("Enter each check and deposit during the month.\n");
X    printf("To indicate a check, use a minus sign.\n");
X    printf("Signal the end of the month with a 0 value.\n");
X    printf("Enter the initial balance: ");
X    balance = GetReal();
X    while (TRUE) {
X        printf("Enter check (-) or deposit: ");
X        entry = GetReal();
X        if (entry == 0) break;
X        balance += entry;
X        if (balance < 0) {
X            printf("This check bounces.  $10 fee deducted.\n");
X            balance -= 10;
X        }
X        printf("Current balance = %g\n", balance);
X    }
X    printf("Final balance = %g\n", balance);
X}
END_OF_FILE
if test 926 -ne `wc -c <'programs/03-Problem-Solving/balance2.c'`; then
    echo shar: \"'programs/03-Problem-Solving/balance2.c'\" unpacked with wrong size!
fi
# end of 'programs/03-Problem-Solving/balance2.c'
fi
if test -f 'programs/03-Problem-Solving/balance3.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/03-Problem-Solving/balance3.c'\"
else
echo shar: Extracting \"'programs/03-Problem-Solving/balance3.c'\" \(982 characters\)
sed "s/^X//" >'programs/03-Problem-Solving/balance3.c' <<'END_OF_FILE'
X/*
X * File: balance3.c
X * ----------------
X * This file contains a corrected version of a program to
X * balance a checkbook, including a working bounced-check
X * feature.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
Xmain()
X{
X    double entry, balance;
X
X    printf("This program helps you balance your checkbook.\n");
X    printf("Enter each check and deposit during the month.\n");
X    printf("To indicate a check, use a minus sign.\n");
X    printf("Signal the end of the month with a 0 value.\n");
X    printf("Enter the initial balance: ");
X    balance = GetReal();
X    while (TRUE) {
X        printf("Enter check (-) or deposit: ");
X        entry = GetReal();
X        if (entry == 0) break;
X        balance += entry;
X        if (balance < 0 && entry < 0) {
X            printf("This check bounces.  $10 fee deducted.\n");
X            balance -= 10;
X        }
X        printf("Current balance = %g\n", balance);
X    }
X    printf("Final balance = %g\n", balance);
X}
END_OF_FILE
if test 982 -ne `wc -c <'programs/03-Problem-Solving/balance3.c'`; then
    echo shar: \"'programs/03-Problem-Solving/balance3.c'\" unpacked with wrong size!
fi
# end of 'programs/03-Problem-Solving/balance3.c'
fi
if test -f 'programs/03-Problem-Solving/balance4.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/03-Problem-Solving/balance4.c'\"
else
echo shar: Extracting \"'programs/03-Problem-Solving/balance4.c'\" \(1288 characters\)
sed "s/^X//" >'programs/03-Problem-Solving/balance4.c' <<'END_OF_FILE'
X/*
X * File: balance4.c
X * ----------------
X * This file contains the final version of a program to
X * balance a checkbook.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
X/*
X * Constant: BouncedCheckFee
X * -------------------------
X * To change the charge assessed for bounced checks, change
X * the definition of this constant.  The constant must be a
X * floating-point value (i.e., must contain a decimal point).
X */
X
X#define BouncedCheckFee 10.00
X
X/* Main program */
X
Xmain()
X{
X    double entry, balance;
X
X    printf("This program helps you balance your checkbook.\n");
X    printf("Enter each check and deposit during the month.\n");
X    printf("To indicate a check, use a minus sign.\n");
X    printf("Signal the end of the month with a 0 value.\n");
X    printf("Enter the initial balance: ");
X    balance = GetReal();
X    while (TRUE) {
X        printf("Enter check (-) or deposit: ");
X        entry = GetReal();
X        if (entry == 0) break;
X        balance += entry;
X        if (entry < 0 && balance < 0) {
X            printf("This check bounces.  $%.2f fee deducted.\n",
X                   BouncedCheckFee);
X            balance -= BouncedCheckFee;
X        }
X        printf("Current balance = %.2f\n", balance);
X    }
X    printf("Final balance = %.2f\n", balance);
X}
END_OF_FILE
if test 1288 -ne `wc -c <'programs/03-Problem-Solving/balance4.c'`; then
    echo shar: \"'programs/03-Problem-Solving/balance4.c'\" unpacked with wrong size!
fi
# end of 'programs/03-Problem-Solving/balance4.c'
fi
if test -f 'programs/03-Problem-Solving/count10.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/03-Problem-Solving/count10.c'\"
else
echo shar: Extracting \"'programs/03-Problem-Solving/count10.c'\" \(252 characters\)
sed "s/^X//" >'programs/03-Problem-Solving/count10.c' <<'END_OF_FILE'
X/*
X * File: count10.c
X * ---------------
X * This program counts from 1 to 10, displaying each number
X * on the screen.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X
Xmain()
X{
X    int i;
X
X    for (i = 1; i <= 10; i++) {
X        printf("%d\n", i);
X    }
X}
END_OF_FILE
if test 252 -ne `wc -c <'programs/03-Problem-Solving/count10.c'`; then
    echo shar: \"'programs/03-Problem-Solving/count10.c'\" unpacked with wrong size!
fi
# end of 'programs/03-Problem-Solving/count10.c'
fi
if test -f 'programs/03-Problem-Solving/roses.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/03-Problem-Solving/roses.c'\"
else
echo shar: Extracting \"'programs/03-Problem-Solving/roses.c'\" \(285 characters\)
sed "s/^X//" >'programs/03-Problem-Solving/roses.c' <<'END_OF_FILE'
X/*
X * File: roses.c
X * -------------
X * This program prints out the Gertrude Stein quotation
X * "a rose is a rose is a rose".
X */
X
X#include <stdio.h>
X#include "genlib.h"
X
Xmain()
X{
X    int i;
X
X    for (i = 0; i < 2; i++) {
X        printf("a rose is ");
X    }
X    printf("a rose.\n");
X}
END_OF_FILE
if test 285 -ne `wc -c <'programs/03-Problem-Solving/roses.c'`; then
    echo shar: \"'programs/03-Problem-Solving/roses.c'\" unpacked with wrong size!
fi
# end of 'programs/03-Problem-Solving/roses.c'
fi
if test -f 'programs/04-Statement-Forms/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/04-Statement-Forms/Makefile'\"
else
echo shar: Extracting \"'programs/04-Statement-Forms/Makefile'\" \(1906 characters\)
sed "s/^X//" >'programs/04-Statement-Forms/Makefile' <<'END_OF_FILE'
X# Makefile for cbook/04-Statement-Forms/programs
X# Created by the ExportAll facility
X# ***************************************************************
X
XPROGRAMS = \
X    leapyear \
X    oddeven \
X    signtest \
X    cardrank \
X    digitsum \
X    addlist \
X    liftoff \
X    timestab 
X
X# ***************************************************************
X# Parameters to control Makefile operation
X# Note that the gccx command script must be defined
X
XCC = gccx
XCFLAGS = 
X
X# ***************************************************************
X# Entry to bring the package up to date
X
Xall: $(PROGRAMS)
X
X# ***************************************************************
X# Standard entries to remove files from the directories
X#    tidy    -- eliminate unwanted files
X#    scratch -- delete derived files in preparation for rebuild
X
Xtidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
Xscratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
X# ***************************************************************
X# C compilations
X
Xleapyear.o: leapyear.c
X	$(CC) $(CFLAGS) -c leapyear.c
X
Xoddeven.o: oddeven.c
X	$(CC) $(CFLAGS) -c oddeven.c
X
Xsigntest.o: signtest.c
X	$(CC) $(CFLAGS) -c signtest.c
X
Xcardrank.o: cardrank.c
X	$(CC) $(CFLAGS) -c cardrank.c
X
Xdigitsum.o: digitsum.c
X	$(CC) $(CFLAGS) -c digitsum.c
X
Xaddlist.o: addlist.c
X	$(CC) $(CFLAGS) -c addlist.c
X
Xliftoff.o: liftoff.c
X	$(CC) $(CFLAGS) -c liftoff.c
X
Xtimestab.o: timestab.c
X	$(CC) $(CFLAGS) -c timestab.c
X
X
Xleapyear: leapyear.o
X	$(CC) $(CFLAGS) -o leapyear leapyear.o
X
Xoddeven: oddeven.o
X	$(CC) $(CFLAGS) -o oddeven oddeven.o
X
Xsigntest: signtest.o
X	$(CC) $(CFLAGS) -o signtest signtest.o
X
Xcardrank: cardrank.o
X	$(CC) $(CFLAGS) -o cardrank cardrank.o
X
Xdigitsum: digitsum.o
X	$(CC) $(CFLAGS) -o digitsum digitsum.o
X
Xaddlist: addlist.o
X	$(CC) $(CFLAGS) -o addlist addlist.o
X
Xliftoff: liftoff.o
X	$(CC) $(CFLAGS) -o liftoff liftoff.o
X
Xtimestab: timestab.o
X	$(CC) $(CFLAGS) -o timestab timestab.o
END_OF_FILE
if test 1906 -ne `wc -c <'programs/04-Statement-Forms/Makefile'`; then
    echo shar: \"'programs/04-Statement-Forms/Makefile'\" unpacked with wrong size!
fi
# end of 'programs/04-Statement-Forms/Makefile'
fi
if test -f 'programs/04-Statement-Forms/addlist.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/04-Statement-Forms/addlist.c'\"
else
echo shar: Extracting \"'programs/04-Statement-Forms/addlist.c'\" \(689 characters\)
sed "s/^X//" >'programs/04-Statement-Forms/addlist.c' <<'END_OF_FILE'
X/*
X * File: addlist.c
X * ---------------
X * This program adds a list of numbers.  The end of the
X * input is indicated by entering 0 as a sentinel value.
X * This version of the implementation uses a while loop
X * without a break statement, which forces some duplication
X * of code.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
Xmain()
X{
X    int value, total;
X
X    printf("This program adds a list of numbers.\n");
X    printf("Signal end of list with a 0.\n");
X    total = 0;
X    printf(" ? ");
X    value = GetInteger();
X    while (value != 0) {
X        total += value;
X        printf(" ? ");
X        value = GetInteger();
X    }
X    printf("The total is %d\n", total);
X}
END_OF_FILE
if test 689 -ne `wc -c <'programs/04-Statement-Forms/addlist.c'`; then
    echo shar: \"'programs/04-Statement-Forms/addlist.c'\" unpacked with wrong size!
fi
# end of 'programs/04-Statement-Forms/addlist.c'
fi
if test -f 'programs/04-Statement-Forms/cardrank.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/04-Statement-Forms/cardrank.c'\"
else
echo shar: Extracting \"'programs/04-Statement-Forms/cardrank.c'\" \(542 characters\)
sed "s/^X//" >'programs/04-Statement-Forms/cardrank.c' <<'END_OF_FILE'
X/*
X * File: cardrank.c
X * ----------------
X * Reads in a number between 1 and 13 and writes out the
X * appropriate symbol for a playing card of that rank.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
Xmain()
X{
X    int n;
X
X    printf("What is the rank of the card (1-13)? ");
X    n = GetInteger();
X    switch (n) {
X      case  1: printf("Ace\n"); break;
X      case 11: printf("Jack\n"); break;
X      case 12: printf("Queen\n"); break;
X      case 13: printf("King\n"); break;
X      default: printf("%d\n", n); break;
X    }
X}
END_OF_FILE
if test 542 -ne `wc -c <'programs/04-Statement-Forms/cardrank.c'`; then
    echo shar: \"'programs/04-Statement-Forms/cardrank.c'\" unpacked with wrong size!
fi
# end of 'programs/04-Statement-Forms/cardrank.c'
fi
if test -f 'programs/04-Statement-Forms/digitsum.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/04-Statement-Forms/digitsum.c'\"
else
echo shar: Extracting \"'programs/04-Statement-Forms/digitsum.c'\" \(631 characters\)
sed "s/^X//" >'programs/04-Statement-Forms/digitsum.c' <<'END_OF_FILE'
X/*
X * File: digitsum.c
X * ----------------
X * This program sums the digits in a positive integer.
X * The program depends on the fact that the last digit of
X * a integer n is given by n % 10 and the number consisting
X * of all but the last digit is given by the expression n / 10.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
Xmain()
X{
X    int n, dsum;
X
X    printf("This program sums the digits in an integer.\n");
X    printf("Enter a positive integer: ");
X    n = GetInteger();
X    dsum = 0;
X    while (n > 0) {
X        dsum += n % 10;
X        n /= 10;
X    }
X    printf("The sum of the digits is %d\n", dsum);
X}
END_OF_FILE
if test 631 -ne `wc -c <'programs/04-Statement-Forms/digitsum.c'`; then
    echo shar: \"'programs/04-Statement-Forms/digitsum.c'\" unpacked with wrong size!
fi
# end of 'programs/04-Statement-Forms/digitsum.c'
fi
if test -f 'programs/04-Statement-Forms/leapyear.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/04-Statement-Forms/leapyear.c'\"
else
echo shar: Extracting \"'programs/04-Statement-Forms/leapyear.c'\" \(727 characters\)
sed "s/^X//" >'programs/04-Statement-Forms/leapyear.c' <<'END_OF_FILE'
X/*
X * File: leapyear.c
X * ----------------
X * Reads in a year and determines whether it is a
X * leap year.  A year is a leap year if it is
X * divisible by four, unless it is divisible by 100.
X * Years divisible by 100 are leap years only if
X * divisible by 400.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
Xmain()
X{
X    int year;
X    bool isLeapYear;
X
X    printf("Program to determine whether a year is a leap year.\n");
X    printf("What year? ");
X    year = GetInteger();
X    isLeapYear = ((year % 4 == 0) && (year % 100 != 0))
X                 || (year % 400 == 0);
X    if (isLeapYear) {
X        printf("%d is a leap year.\n", year);
X    } else {
X        printf("%d is not a leap year.\n", year);
X    }
X}
END_OF_FILE
if test 727 -ne `wc -c <'programs/04-Statement-Forms/leapyear.c'`; then
    echo shar: \"'programs/04-Statement-Forms/leapyear.c'\" unpacked with wrong size!
fi
# end of 'programs/04-Statement-Forms/leapyear.c'
fi
if test -f 'programs/04-Statement-Forms/liftoff.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/04-Statement-Forms/liftoff.c'\"
else
echo shar: Extracting \"'programs/04-Statement-Forms/liftoff.c'\" \(446 characters\)
sed "s/^X//" >'programs/04-Statement-Forms/liftoff.c' <<'END_OF_FILE'
X/*
X * File: liftoff.c
X * ---------------
X * Simulates a countdown for a rocket launch.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X
X/*
X * Constant: StartingCount
X * -----------------------
X * Change this constant to use a different starting value
X * for the countdown.
X */
X
X#define StartingCount 10
X
X/* Main program */
X
Xmain()
X{
X    int t;
X
X    for (t = StartingCount; t >= 0; t--) {
X        printf("%2d\n", t);
X    }
X    printf("Liftoff!\n");
X}
END_OF_FILE
if test 446 -ne `wc -c <'programs/04-Statement-Forms/liftoff.c'`; then
    echo shar: \"'programs/04-Statement-Forms/liftoff.c'\" unpacked with wrong size!
fi
# end of 'programs/04-Statement-Forms/liftoff.c'
fi
if test -f 'programs/04-Statement-Forms/oddeven.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/04-Statement-Forms/oddeven.c'\"
else
echo shar: Extracting \"'programs/04-Statement-Forms/oddeven.c'\" \(414 characters\)
sed "s/^X//" >'programs/04-Statement-Forms/oddeven.c' <<'END_OF_FILE'
X/*
X * File: oddeven.c
X * ---------------
X * Reads in a number and classifies it as even or odd.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
Xmain()
X{
X    int n;
X
X    printf("Program to classify a number as even or odd.\n");
X    printf("n = ? ");
X    n = GetInteger();
X    if (n % 2 == 0) {
X        printf("That number is even.\n");
X    } else {
X        printf("That number is odd.\n");
X    }
X}
END_OF_FILE
if test 414 -ne `wc -c <'programs/04-Statement-Forms/oddeven.c'`; then
    echo shar: \"'programs/04-Statement-Forms/oddeven.c'\" unpacked with wrong size!
fi
# end of 'programs/04-Statement-Forms/oddeven.c'
fi
if test -f 'programs/04-Statement-Forms/signtest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/04-Statement-Forms/signtest.c'\"
else
echo shar: Extracting \"'programs/04-Statement-Forms/signtest.c'\" \(491 characters\)
sed "s/^X//" >'programs/04-Statement-Forms/signtest.c' <<'END_OF_FILE'
X/*
X * File: signtest.c
X * ----------------
X * Reads in a number and classifies it according to its sign.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
Xmain()
X{
X    int n;
X
X    printf("Program to classify a number by its sign.\n");
X    printf("n = ? ");
X    n = GetInteger();
X    if (n > 0) {
X        printf("That number is positive.\n");
X    } else if (n == 0) {
X        printf("That number is zero.\n");
X    } else {
X        printf("That number is negative.\n");
X    }
X}
END_OF_FILE
if test 491 -ne `wc -c <'programs/04-Statement-Forms/signtest.c'`; then
    echo shar: \"'programs/04-Statement-Forms/signtest.c'\" unpacked with wrong size!
fi
# end of 'programs/04-Statement-Forms/signtest.c'
fi
if test -f 'programs/04-Statement-Forms/timestab.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/04-Statement-Forms/timestab.c'\"
else
echo shar: Extracting \"'programs/04-Statement-Forms/timestab.c'\" \(568 characters\)
sed "s/^X//" >'programs/04-Statement-Forms/timestab.c' <<'END_OF_FILE'
X/*
X * File: timestab.c
X * ----------------
X * Generates a multiplication table where each axis
X * runs from LowerLimit to UpperLimit.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X
X/*
X * Constants
X * ---------
X * LowerLimit -- Starting value for the table
X * UpperLimit -- Final value for the table
X */
X
X#define LowerLimit  1
X#define UpperLimit 10
X
X/* Main program */
X
Xmain()
X{
X    int i, j;
X
X    for (i = LowerLimit; i <= UpperLimit; i++) {
X        for (j = LowerLimit; j <= UpperLimit; j++) {
X            printf(" %4d", i * j);
X        }
X        printf("\n");
X    }
X}
END_OF_FILE
if test 568 -ne `wc -c <'programs/04-Statement-Forms/timestab.c'`; then
    echo shar: \"'programs/04-Statement-Forms/timestab.c'\" unpacked with wrong size!
fi
# end of 'programs/04-Statement-Forms/timestab.c'
fi
if test -f 'programs/05-Functions/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/05-Functions/Makefile'\"
else
echo shar: Extracting \"'programs/05-Functions/Makefile'\" \(1604 characters\)
sed "s/^X//" >'programs/05-Functions/Makefile' <<'END_OF_FILE'
X# Makefile for cbook/05-Functions/programs
X# Created by the ExportAll facility
X# ***************************************************************
X
XPROGRAMS = \
X    gameloop \
X    iseven \
X    c2ftable \
X    fact \
X    combine \
X    calendar 
X
X# ***************************************************************
X# Parameters to control Makefile operation
X# Note that the gccx command script must be defined
X
XCC = gccx
XCFLAGS = 
X
X# ***************************************************************
X# Entry to bring the package up to date
X
Xall: $(PROGRAMS)
X
X# ***************************************************************
X# Standard entries to remove files from the directories
X#    tidy    -- eliminate unwanted files
X#    scratch -- delete derived files in preparation for rebuild
X
Xtidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
Xscratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
X# ***************************************************************
X# C compilations
X
Xgameloop.o: gameloop.c
X	$(CC) $(CFLAGS) -c gameloop.c
X
Xiseven.o: iseven.c
X	$(CC) $(CFLAGS) -c iseven.c
X
Xc2ftable.o: c2ftable.c
X	$(CC) $(CFLAGS) -c c2ftable.c
X
Xfact.o: fact.c
X	$(CC) $(CFLAGS) -c fact.c
X
Xcombine.o: combine.c
X	$(CC) $(CFLAGS) -c combine.c
X
Xcalendar.o: calendar.c
X	$(CC) $(CFLAGS) -c calendar.c
X
X
Xgameloop: gameloop.o
X	$(CC) $(CFLAGS) -o gameloop gameloop.o
X
Xiseven: iseven.o
X	$(CC) $(CFLAGS) -o iseven iseven.o
X
Xc2ftable: c2ftable.o
X	$(CC) $(CFLAGS) -o c2ftable c2ftable.o
X
Xfact: fact.o
X	$(CC) $(CFLAGS) -o fact fact.o
X
Xcombine: combine.o
X	$(CC) $(CFLAGS) -o combine combine.o
X
Xcalendar: calendar.o
X	$(CC) $(CFLAGS) -o calendar calendar.o
END_OF_FILE
if test 1604 -ne `wc -c <'programs/05-Functions/Makefile'`; then
    echo shar: \"'programs/05-Functions/Makefile'\" unpacked with wrong size!
fi
# end of 'programs/05-Functions/Makefile'
fi
if test -f 'programs/05-Functions/c2ftable.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/05-Functions/c2ftable.c'\"
else
echo shar: Extracting \"'programs/05-Functions/c2ftable.c'\" \(1023 characters\)
sed "s/^X//" >'programs/05-Functions/c2ftable.c' <<'END_OF_FILE'
X/*
X * File: c2ftable.c
X * ----------------
X * This program illustrates the use of functions by generating
X * a table of Celsius to Fahrenheit conversions.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X
X/*
X * Constants
X * ---------
X * LowerLimit -- Starting value for temperature table
X * UpperLimit -- Final value for temperature table
X * StepSize   -- Step size between table entries
X */
X
X#define LowerLimit   0
X#define UpperLimit 100
X#define StepSize     5
X
X/* Function prototypes */
X
Xdouble CelsiusToFahrenheit(double c);
X
X/* Main program */
X
Xmain()
X{
X    int c;
X
X    printf("Celsius to Fahrenheit table.\n");
X    printf("  C    F\n");
X    for (c = LowerLimit; c <= UpperLimit; c += StepSize) {
X        printf("%3d  %3g\n", c, CelsiusToFahrenheit(c));
X    }
X}
X
X/*
X * Function: CelsiusToFahrenheit
X * Usage: f = CelsiusToFahrenheit(c);
X * ----------------------------------
X * Returns the Fahrenheit equivalent of the Celsius
X * temperature c.
X */
X
Xdouble CelsiusToFahrenheit(double c)
X{
X    return (9.0 / 5.0 * c + 32);
X}
END_OF_FILE
if test 1023 -ne `wc -c <'programs/05-Functions/c2ftable.c'`; then
    echo shar: \"'programs/05-Functions/c2ftable.c'\" unpacked with wrong size!
fi
# end of 'programs/05-Functions/c2ftable.c'
fi
if test -f 'programs/05-Functions/calendar.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/05-Functions/calendar.c'\"
else
echo shar: Extracting \"'programs/05-Functions/calendar.c'\" \(5334 characters\)
sed "s/^X//" >'programs/05-Functions/calendar.c' <<'END_OF_FILE'
X/*
X * File: calendar.c
X * ----------------
X * This program is used to generate a calendar for a year
X * entered by the user.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
X/*
X * Constants:
X * ----------
X * Days of the week are represented by the integers 0-6.
X * Months of the year are identified by the integers 1-12;
X * because this numeric representation for months is in
X * common use, no special constants are defined.
X */
X
X#define Sunday     0
X#define Monday     1
X#define Tuesday    2
X#define Wednesday  3
X#define Thursday   4
X#define Friday     5
X#define Saturday   6
X
X/* Function prototypes */
X
Xvoid GiveInstructions(void);
Xint GetYearFromUser(void);
Xvoid PrintCalendar(int year);
Xvoid PrintCalendarMonth(int month, int year);
Xvoid IndentFirstLine(int weekday);
Xint MonthDays(int month, int year);
Xint FirstDayOfMonth(int month, int year);
Xstring MonthName(int month);
Xbool IsLeapYear(int year);
X
X/* Main program */
X
Xmain()
X{
X    int year;
X
X    GiveInstructions();
X    year = GetYearFromUser();
X    PrintCalendar(year);
X}
X
X/*
X * Function: GiveInstructions
X * Usage: GiveInstructions();
X * --------------------------
X * This procedure prints out instructions to the user.
X */
X
Xvoid GiveInstructions(void)
X{
X    printf("This program displays a calendar for a full\n");
X    printf("year.  The year must not be before 1900.\n");
X}
X
X/*
X * Function: GetYearFromUser
X * Usage: year = GetYearFromUser();
X * --------------------------------
X * This function reads in a year from the user and returns
X * that value.  If the user enters a year before 1900, the
X * function gives the user another chance.
X */
X
Xint GetYearFromUser(void)
X{
X    int year;
X
X    while (TRUE) {
X        printf("Which year? ");
X        year = GetInteger();
X        if (year >= 1900) return (year);
X        printf("The year must be at least 1900.\n");
X    }
X}
X
X/*
X * Function: PrintCalendar
X * Usage: PrintCalendar(year);
X * ---------------------------
X * This procedure prints a calendar for an entire year.
X */
X
Xvoid PrintCalendar(int year)
X{
X    int month;
X
X    for (month = 1; month <= 12; month++) {
X        PrintCalendarMonth(month, year);
X        printf("\n");
X    }
X}
X
X/*
X * Function: PrintCalendarMonth
X * Usage: PrintCalendarMonth(month, year);
X * ---------------------------------------
X * This procedure prints a calendar for the given month
X * and year.
X */
X
Xvoid PrintCalendarMonth(int month, int year)
X{
X    int weekday, nDays, day;
X
X    printf("    %s %d\n", MonthName(month), year);
X    printf(" Su Mo Tu We Th Fr Sa\n");
X    nDays = MonthDays(month, year);
X    weekday = FirstDayOfMonth(month, year);
X    IndentFirstLine(weekday);
X    for (day = 1; day <= nDays; day++) {
X        printf(" %2d", day);
X        if (weekday == Saturday) printf("\n");
X        weekday = (weekday + 1) % 7;
X    }
X    if (weekday != Sunday) printf("\n");
X}
X
X/*
X * Function: IndentFirstLine
X * Usage: IndentFirstLine(weekday);
X * --------------------------------
X * This procedure indents the first line of the calendar
X * by printing enough blank spaces to get to the position
X * on the line corresponding to weekday.
X */
X
Xvoid IndentFirstLine(int weekday)
X{
X    int i;
X
X    for (i = 0; i < weekday; i++) {
X        printf("   ");
X    }
X}
X
X/*
X * Function: MonthDays
X * Usage: ndays = MonthDays(month, year);
X * --------------------------------------
X * MonthDays returns the number of days in the indicated
X * month and year.  The year is required to handle leap years.
X */
X
Xint MonthDays(int month, int year)
X{
X    switch (month) {
X      case 2:
X        if (IsLeapYear(year)) return (29);
X        return (28);
X      case 4: case 6: case 9: case 11:
X        return (30);
X      default:
X        return (31);
X    }
X}
X
X/*
X * Function: FirstDayOfMonth
X * Usage: weekday = FirstDayOfMonth(month, year);
X * ----------------------------------------------
X * This function returns the day of the week on which the
X * indicated month begins.  This program simply counts
X * forward from January 1, 1900, which was a Monday.
X */
X
Xint FirstDayOfMonth(int month, int year)
X{
X    int weekday, i;
X
X    weekday = Monday;
X    for (i = 1900; i < year; i++) {
X        weekday = (weekday + 365) % 7;
X        if (IsLeapYear(i)) weekday = (weekday + 1) % 7;
X    }
X    for (i = 1; i < month; i++) {
X        weekday = (weekday + MonthDays(i, year)) % 7;
X    }
X    return (weekday);
X}
X
X/*
X * Function: MonthName
X * Usage: name = MonthName(month);
X * -------------------------------
X * MonthName converts a numeric month in the range 1-12
X * into the string name for that month.
X */
X
Xstring MonthName(int month)
X{
X    switch (month) {
X      case  1: return ("January");
X      case  2: return ("February");
X      case  3: return ("March");
X      case  4: return ("April");
X      case  5: return ("May");
X      case  6: return ("June");
X      case  7: return ("July");
X      case  8: return ("August");
X      case  9: return ("September");
X      case 10: return ("October");
X      case 11: return ("November");
X      case 12: return ("December");
X      default: return ("Illegal month");
X    }
X}
X
X/*
X * Function: IsLeapYear
X * Usage: if (IsLeapYear(year)) . . .
X * ----------------------------------
X * This function returns TRUE if year is a leap year.
X */
X
Xbool IsLeapYear(int year)
X{
X    return ( ((year % 4 == 0) && (year % 100 != 0))
X             || (year % 400 == 0) );
X}
END_OF_FILE
if test 5334 -ne `wc -c <'programs/05-Functions/calendar.c'`; then
    echo shar: \"'programs/05-Functions/calendar.c'\" unpacked with wrong size!
fi
# end of 'programs/05-Functions/calendar.c'
fi
if test -f 'programs/05-Functions/combine.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/05-Functions/combine.c'\"
else
echo shar: Extracting \"'programs/05-Functions/combine.c'\" \(1523 characters\)
sed "s/^X//" >'programs/05-Functions/combine.c' <<'END_OF_FILE'
X/*
X * File: combine.c
X * ---------------
X * This program tests a function to compute the mathematical
X * combination function Combinations(n, k), which gives the
X * number of ways to choose a subset of k objects from a set
X * of n distinct objects.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
X/* Function prototypes */
X
Xint Combinations(int n, int k);
Xint Factorial(int n);
X
X/* Main program */
X
Xmain()
X{
X    int n, k;
X
X    printf("Enter number of objects in the set (n)? ");
X    n = GetInteger();
X    printf("Enter number to be chosen (k)? ");
X    k = GetInteger();
X    printf("C(%d, %d) = %d\n", n, k, Combinations(n, k));
X}
X
X/*
X * Function: Combinations
X * Usage: ways = Combinations(n, k);
X * ---------------------------------
X * Implements the Combinations function, which returns the number
X * of distinct ways of choosing k objects from a set of n objects.
X * In mathematics, this function is often written as C(n,k), but a
X * function called C is not very self-descriptive, particularly in
X * a language which has precisely the same name.
X */
X
Xint Combinations(int n, int k)
X{
X    return (Factorial(n) / (Factorial(k) * Factorial(n - k)));
X}
X
X/*
X * Function: Factorial
X * Usage: f = Factorial(n);
X * ------------------------
X * Returns the factorial of the argument n, where factorial
X * is defined as the product of all integers from 1 up to n.
X */
X
Xint Factorial(int n)
X{
X    int product, i;
X
X    product = 1;
X    for (i = 1; i <= n; i++) {
X        product *= i;
X    }
X    return (product);
X}
END_OF_FILE
if test 1523 -ne `wc -c <'programs/05-Functions/combine.c'`; then
    echo shar: \"'programs/05-Functions/combine.c'\" unpacked with wrong size!
fi
# end of 'programs/05-Functions/combine.c'
fi
if test -f 'programs/05-Functions/fact.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/05-Functions/fact.c'\"
else
echo shar: Extracting \"'programs/05-Functions/fact.c'\" \(970 characters\)
sed "s/^X//" >'programs/05-Functions/fact.c' <<'END_OF_FILE'
X/*
X * File: fact.c
X * ------------
X * This program includes the Factorial function and a test
X * program that prints the factorials of the numbers between
X * the limits LowerLimit and UpperLimit, inclusive.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X
X/*
X * Constants
X * ---------
X * LowerLimit -- Starting value for factorial table
X * UpperLimit -- Final value for factorial table
X */
X
X#define LowerLimit 0
X#define UpperLimit 7
X
X/* Function prototypes */
X
Xint Factorial(int n);
X
X/* Main program */
X
Xmain()
X{
X    int i;
X
X    for (i = LowerLimit; i <= UpperLimit; i++) {
X        printf("%d! = %5d\n", i, Factorial(i));
X    }
X}
X
X/*
X * Function: Factorial
X * Usage: f = Factorial(n);
X * ------------------------
X * This function returns the factorial of n, which is defined
X * as the product of all integers from 1 up to n.
X */
X
Xint Factorial(int n)
X{
X    int product, i;
X
X    product = 1;
X    for (i = 1; i <= n; i++) {
X        product *= i;
X    }
X    return (product);
X}
END_OF_FILE
if test 970 -ne `wc -c <'programs/05-Functions/fact.c'`; then
    echo shar: \"'programs/05-Functions/fact.c'\" unpacked with wrong size!
fi
# end of 'programs/05-Functions/fact.c'
fi
if test -f 'programs/05-Functions/gameloop.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/05-Functions/gameloop.c'\"
else
echo shar: Extracting \"'programs/05-Functions/gameloop.c'\" \(711 characters\)
sed "s/^X//" >'programs/05-Functions/gameloop.c' <<'END_OF_FILE'
X/*
X * File: gameloop.c
X * ----------------
X * This program is used as an illustration of the
X * StringEqual function.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X#include "strlib.h"
X
X/* Function prototypes */
X
Xvoid PlayOneGame(void);
X
X/* Main program */
X
Xmain()
X{
X    string answer;
X
X    while (TRUE) {
X        PlayOneGame();
X        printf("Would you like to play again? ");
X        answer = GetLine();
X        if (StringEqual(answer, "no")) break;
X    }
X}
X
X/*
X * Function: PlayOneGame
X * Usage: PlayOneGame();
X * ---------------------
X * This is a dummy function that could be replaced by
X * any game-playing program.
X */
X
Xvoid PlayOneGame()
X{
X    printf(". . . play the game . . .\n");
X}
END_OF_FILE
if test 711 -ne `wc -c <'programs/05-Functions/gameloop.c'`; then
    echo shar: \"'programs/05-Functions/gameloop.c'\" unpacked with wrong size!
fi
# end of 'programs/05-Functions/gameloop.c'
fi
if test -f 'programs/05-Functions/iseven.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/05-Functions/iseven.c'\"
else
echo shar: Extracting \"'programs/05-Functions/iseven.c'\" \(656 characters\)
sed "s/^X//" >'programs/05-Functions/iseven.c' <<'END_OF_FILE'
X/*
X * File: iseven.c
X * --------------
X * This program prints a list of the even numbers between
X * 1 and 10.  In an ideal implementation, constants would
X * be used for the limits, but this program is designed to
X * match the program example in the text.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X
X/* Function prototypes */
X
Xbool IsEven(int n);
X
X/* Main program */
X
Xmain()
X{
X    int i;
X
X    for (i = 1; i <= 10; i++) {
X        if (IsEven(i)) printf("%2d\n", i);
X    }
X}
X
X/*
X * Function: IsEven
X * Usage: if (IsEven(n)) . . .
X * ---------------------------
X * This function returns TRUE if n is even.
X */
X
Xbool IsEven(int n)
X{
X    return (n % 2 == 0);
X}
END_OF_FILE
if test 656 -ne `wc -c <'programs/05-Functions/iseven.c'`; then
    echo shar: \"'programs/05-Functions/iseven.c'\" unpacked with wrong size!
fi
# end of 'programs/05-Functions/iseven.c'
fi
if test -f 'programs/06-Algorithms/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/06-Algorithms/Makefile'\"
else
echo shar: Extracting \"'programs/06-Algorithms/Makefile'\" \(1765 characters\)
sed "s/^X//" >'programs/06-Algorithms/Makefile' <<'END_OF_FILE'
X# Makefile for cbook/06-Algorithms/programs
X# Created by the ExportAll facility
X# ***************************************************************
X
XPROGRAMS = \
X    primes1 \
X    primes2 \
X    primes3 \
X    gcd \
X    euclid \
X    nsqrt \
X    zeno \
X    tsqrt 
X
X# ***************************************************************
X# Parameters to control Makefile operation
X# Note that the gccx command script must be defined
X
XCC = gccx
XCFLAGS = 
X
X# ***************************************************************
X# Entry to bring the package up to date
X
Xall: $(PROGRAMS)
X
X# ***************************************************************
X# Standard entries to remove files from the directories
X#    tidy    -- eliminate unwanted files
X#    scratch -- delete derived files in preparation for rebuild
X
Xtidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
Xscratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
X# ***************************************************************
X# C compilations
X
Xprimes1.o: primes1.c
X	$(CC) $(CFLAGS) -c primes1.c
X
Xprimes2.o: primes2.c
X	$(CC) $(CFLAGS) -c primes2.c
X
Xprimes3.o: primes3.c
X	$(CC) $(CFLAGS) -c primes3.c
X
Xgcd.o: gcd.c
X	$(CC) $(CFLAGS) -c gcd.c
X
Xeuclid.o: euclid.c
X	$(CC) $(CFLAGS) -c euclid.c
X
Xnsqrt.o: nsqrt.c
X	$(CC) $(CFLAGS) -c nsqrt.c
X
Xzeno.o: zeno.c
X	$(CC) $(CFLAGS) -c zeno.c
X
Xtsqrt.o: tsqrt.c
X	$(CC) $(CFLAGS) -c tsqrt.c
X
X
Xprimes1: primes1.o
X	$(CC) $(CFLAGS) -o primes1 primes1.o
X
Xprimes2: primes2.o
X	$(CC) $(CFLAGS) -o primes2 primes2.o
X
Xprimes3: primes3.o
X	$(CC) $(CFLAGS) -o primes3 primes3.o
X
Xgcd: gcd.o
X	$(CC) $(CFLAGS) -o gcd gcd.o
X
Xeuclid: euclid.o
X	$(CC) $(CFLAGS) -o euclid euclid.o
X
Xnsqrt: nsqrt.o
X	$(CC) $(CFLAGS) -o nsqrt nsqrt.o
X
Xzeno: zeno.o
X	$(CC) $(CFLAGS) -o zeno zeno.o
X
Xtsqrt: tsqrt.o
X	$(CC) $(CFLAGS) -o tsqrt tsqrt.o
END_OF_FILE
if test 1765 -ne `wc -c <'programs/06-Algorithms/Makefile'`; then
    echo shar: \"'programs/06-Algorithms/Makefile'\" unpacked with wrong size!
fi
# end of 'programs/06-Algorithms/Makefile'
fi
if test -f 'programs/06-Algorithms/euclid.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/06-Algorithms/euclid.c'\"
else
echo shar: Extracting \"'programs/06-Algorithms/euclid.c'\" \(938 characters\)
sed "s/^X//" >'programs/06-Algorithms/euclid.c' <<'END_OF_FILE'
X/*
X * File: euclid.c
X * --------------
X * This program computes a greates common divisor using
X * Euclid's algorithm.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
X/* Function prototypes */
X
Xint GCD(int x, int y);
X
X/* Main program */
X
Xmain()
X{
X    int x, y;
X
X    printf("This program calculates greatest common divisors.\n");
X    printf("Enter two integers, x and y.\n");
X    printf("x = ? ");
X    x = GetInteger();
X    printf("y = ? ");
X    y = GetInteger();
X    printf("The gcd of %d and %d is %d.\n", x, y, GCD(x, y));
X}
X
X/*
X * Function: GCD
X * Usage: gcd = GCD(x, y);
X * -----------------------
X * Returns the greatest common divisor of x and y,
X * calculated by Euclid's algorithm, which is discussed
X * as Proposition 7 in Book II of Euclid's Elements.
X */
X
Xint GCD(int x, int y)
X{
X    int r;
X
X    while (TRUE) {
X        r = x % y;
X        if (r == 0) break;
X        x = y;
X        y = r;
X    }
X    return (y);
X}
END_OF_FILE
if test 938 -ne `wc -c <'programs/06-Algorithms/euclid.c'`; then
    echo shar: \"'programs/06-Algorithms/euclid.c'\" unpacked with wrong size!
fi
# end of 'programs/06-Algorithms/euclid.c'
fi
if test -f 'programs/06-Algorithms/gcd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/06-Algorithms/gcd.c'\"
else
echo shar: Extracting \"'programs/06-Algorithms/gcd.c'\" \(870 characters\)
sed "s/^X//" >'programs/06-Algorithms/gcd.c' <<'END_OF_FILE'
X/*
X * File: gcd.c
X * -----------
X * This program computes a greatest common divisor using
X * a brute-force algorithm.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
X/* Function prototypes */
X
Xint GCD(int x, int y);
X
X/* Main program */
X
Xmain()
X{
X    int x, y;
X
X    printf("This program calculates greatest common divisors.\n");
X    printf("Enter two integers, x and y.\n");
X    printf("x = ? ");
X    x = GetInteger();
X    printf("y = ? ");
X    y = GetInteger();
X    printf("The gcd of %d and %d is %d.\n", x, y, GCD(x, y));
X}
X
X/*
X * Function: GCD
X * Usage: gcd = GCD(x, y);
X * -----------------------
X * Returns the greatest common divisor of x and y,
X * calculated by the brute-force method of testing
X * every possibility.
X */
X
Xint GCD(int x, int y)
X{
X    int g;
X
X    g = x;
X    while (x % g != 0 || y % g != 0) {
X        g--;
X    }
X    return (g);
X}
END_OF_FILE
if test 870 -ne `wc -c <'programs/06-Algorithms/gcd.c'`; then
    echo shar: \"'programs/06-Algorithms/gcd.c'\" unpacked with wrong size!
fi
# end of 'programs/06-Algorithms/gcd.c'
fi
if test -f 'programs/06-Algorithms/nsqrt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/06-Algorithms/nsqrt.c'\"
else
echo shar: Extracting \"'programs/06-Algorithms/nsqrt.c'\" \(2633 characters\)
sed "s/^X//" >'programs/06-Algorithms/nsqrt.c' <<'END_OF_FILE'
X/*
X * File: nsqrt.c
X * -------------
X * This program calculates square roots using Newton's
X * method for successive approximation.
X */
X
X#include <stdio.h>
X#include <math.h>
X#include "genlib.h"
X
X/*
X * Constants:
X * ----------
X * Epsilon -- The acceptable fraction of difference between
X *            two values that are approximately equal.
X */
X
X#define Epsilon 0.0000000001
X
X/* Function prototypes */
X
Xvoid TestSqrt(double x);
Xdouble Sqrt(double x);
Xbool ApproximatelyEqual(double x, double y);
Xdouble MinF(double x, double y);
X
X/* Main program */
X
Xmain()
X{
X    TestSqrt(0.0);
X    TestSqrt(0.25);
X    TestSqrt(1);
X    TestSqrt(2);
X    TestSqrt(3);
X    TestSqrt(4);
X    TestSqrt(49);
X    TestSqrt(200);
X    TestSqrt(1.0E10);
X}
X
X/*
X * Function: TestSqrt
X * Usage: TestSqrt(x);
X * -------------------
X * Generates a line of the test table.
X */
X
Xvoid TestSqrt(double x)
X{
X    double computed, actual;
X
X    computed = Sqrt(x);
X    actual = sqrt(x);
X    printf("Sqrt(%g) = %g  sqrt(%g) = %g\n", x, computed, x, actual);
X    if (!ApproximatelyEqual(computed, actual)) {
X        printf("Warning! Computed value does not match actual!\n");
X    }
X}
X
X/*
X * Function: Sqrt
X * Usage: root = Sqrt(x);
X * ----------------------
X * Returns the square root of x, calculated using
X * Newton's algorithm, as described in the text.
X */
X
Xdouble Sqrt(double x)
X{
X    double g;
X
X    if (x == 0) return (0);
X    if (x < 0) Error("Sqrt called with negative argument %g", x);
X    g = x;
X    while (!ApproximatelyEqual(x, g * g)) {
X        g = (g + x / g) / 2;
X    }
X    return (g);
X}
X
X/*
X * Function: ApproximatelyEqual
X * Usage: if (ApproximatelyEqual(x, y)) . . .
X * ------------------------------------------
X * Returns TRUE if x and y are approximately equal, as
X * indicated by the formula:
X *
X *       | x - y |
X *     -------------  <  Epsilon
X *     min(|x|, |y|)
X *
X * To avoid the possibility of division by 0, the function
X * first tests to make sure that adding the denominator to
X * the numerator of this fraction changes the nominator.
X * This test has the same practical effect as checking
X * against 0 but avoids overflow in the case that the
X * denominator is very small.
X */
X
Xbool ApproximatelyEqual(double x, double y)
X{
X    double num, den;
X
X    num = fabs(x - y);
X    den = MinF(fabs(x), fabs(y));
X    if (num + den == num) return (x == y);
X    return (num / den < Epsilon);
X}
X
X/*
X * Function: MinF
X * Usage: min = MinF(x, y);
X * ------------------------
X * Returns the smaller of the two floating-point values x and y.
X */
X
Xdouble MinF(double x, double y)
X{
X    if (x < y) {
X        return (x);
X    } else {
X        return (y);
X    }
X}
END_OF_FILE
if test 2633 -ne `wc -c <'programs/06-Algorithms/nsqrt.c'`; then
    echo shar: \"'programs/06-Algorithms/nsqrt.c'\" unpacked with wrong size!
fi
# end of 'programs/06-Algorithms/nsqrt.c'
fi
if test -f 'programs/06-Algorithms/primes1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/06-Algorithms/primes1.c'\"
else
echo shar: Extracting \"'programs/06-Algorithms/primes1.c'\" \(1000 characters\)
sed "s/^X//" >'programs/06-Algorithms/primes1.c' <<'END_OF_FILE'
X/*
X * File: primes1.c
X * ---------------
X * This program prints out a list of all prime numbers between
X * the limits LowerLimit and UpperLimit.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X
X/*
X * Constants
X * ---------
X * LowerLimit -- Starting value for the prime search
X * UpperLimit -- Final value for the prime search
X */
X
X#define LowerLimit 0
X#define UpperLimit 1000
X
X/* Function prototypes */
X
Xbool IsPrime(int n);
X
X/* Main program */
X
Xmain()
X{
X    int i;
X
X    printf("This program lists the primes between %d and %d.\n",
X           LowerLimit, UpperLimit);
X    for (i = LowerLimit; i <= UpperLimit; i++) {
X        if (IsPrime(i)) {
X            printf("%4d\n", i);
X        }
X    }
X}
X
X/*
X * Function: IsPrime
X * Usage: if (IsPrime(n)) . . .
X * ----------------------------
X * Returns TRUE if n is prime, and FALSE otherwise.
X */
X
Xbool IsPrime(int n)
X{
X    int divisors, i;
X
X    divisors = 0;
X    for (i = 1; i <= n; i++) {
X        if (n % i == 0) divisors++;
X    }
X    return (divisors == 2);
X}
END_OF_FILE
if test 1000 -ne `wc -c <'programs/06-Algorithms/primes1.c'`; then
    echo shar: \"'programs/06-Algorithms/primes1.c'\" unpacked with wrong size!
fi
# end of 'programs/06-Algorithms/primes1.c'
fi
if test -f 'programs/06-Algorithms/primes2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/06-Algorithms/primes2.c'\"
else
echo shar: Extracting \"'programs/06-Algorithms/primes2.c'\" \(1906 characters\)
sed "s/^X//" >'programs/06-Algorithms/primes2.c' <<'END_OF_FILE'
X/*
X * File: primes2.c                  (WARNING -- BUGGY PROGRAM)
X * ---------------
X * This program prints out a list of all prime numbers between
X * the limits LowerLimit and UpperLimit.  This version attempts
X * to use a more efficient algorithm than the one in primes.c
X * to implement the IsPrime function, but the result is both
X * buggy for certain argument values and surprisingly inefficient
X * when it does work.
X */
X
X#include <stdio.h>
X#include <math.h>
X#include "genlib.h"
X
X/*
X * Constants
X * ---------
X * LowerLimit -- Starting value for the prime search
X * UpperLimit -- Final value for the prime search
X */
X
X#define LowerLimit 0
X#define UpperLimit 1000
X
X/* Function prototypes */
X
Xbool IsPrime(int n);
X
X/* Main program */
X
Xmain()
X{
X    int i;
X
X    printf("This program lists the primes between %d and %d.\n",
X           LowerLimit, UpperLimit);
X    for (i = LowerLimit; i <= UpperLimit; i++) {
X        if (IsPrime(i)) {
X            printf("%4d\n", i);
X        }
X    }
X}
X
X/*
X * Function: IsPrime
X * Usage: if (IsPrime(n)) . . .
X * ----------------------------
X * Returns TRUE if n is prime, and FALSE otherwise.  The
X * implementation takes account of the following observations:
X *
X * 1.  Even numbers are not prime (with the exception of
X *     2, which this buggy program incorrectly classifies).
X *
X * 2.  If the only concern of the function is determining
X *     whether the number is prime, there is no reason to
X *     continue the loop after a factor is found.
X *
X * 3.  If a number n has a factor f larger than the square root
X *     of n, then n/f must also be a factor and must be smaller
X *     than the square root of n.  Thus, it is sufficient to
X *     check only factors up to the square root.
X */
X
Xbool IsPrime(int n)
X{
X    int i;
X
X    if (n % 2 == 0) return (FALSE);
X    for (i = 3; i <= sqrt(n); i += 2) {
X        if (n % i == 0) return (FALSE);
X    }
X    return (TRUE);
X}
END_OF_FILE
if test 1906 -ne `wc -c <'programs/06-Algorithms/primes2.c'`; then
    echo shar: \"'programs/06-Algorithms/primes2.c'\" unpacked with wrong size!
fi
# end of 'programs/06-Algorithms/primes2.c'
fi
if test -f 'programs/06-Algorithms/primes3.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/06-Algorithms/primes3.c'\"
else
echo shar: Extracting \"'programs/06-Algorithms/primes3.c'\" \(2151 characters\)
sed "s/^X//" >'programs/06-Algorithms/primes3.c' <<'END_OF_FILE'
X/*
X * File: primes3.c
X * ---------------
X * This program prints out a list of all prime numbers between
X * the limits LowerLimit and UpperLimit.  This version corrects
X * the errors in primes2.c and results in an implementation of
X * the IsPrime function than is in fact more efficient than the
X * one given in primes.c.
X */
X
X#include <stdio.h>
X#include <math.h>
X#include "genlib.h"
X
X/*
X * Constants
X * ---------
X * LowerLimit -- Starting value for the prime search
X * UpperLimit -- Final value for the prime search
X */
X
X#define LowerLimit 0
X#define UpperLimit 1000
X
X/* Function prototypes */
X
Xbool IsPrime(int n);
X
X/* Main program */
X
Xmain()
X{
X    int i;
X
X    printf("This program lists the primes between %d and %d.\n",
X           LowerLimit, UpperLimit);
X    for (i = LowerLimit; i <= UpperLimit; i++) {
X        if (IsPrime(i)) {
X            printf("%4d\n", i);
X        }
X    }
X}
X
X/*
X * Function: IsPrime
X * Usage: if (IsPrime(n)) . . .
X * ----------------------------
X * Returns TRUE if n is prime, and FALSE otherwise.  The
X * implementation takes account of the following observations:
X *
X * 1.  Except for 2, no even numbers can be prime.  Thus
X *     it is possible to make one check for 2 and then
X *     test only odd divisors.
X *
X * 2.  If the only concern of the function is determining
X *     whether the number is prime, there is no reason to
X *     continue the loop after a factor is found.
X *
X * 3.  If a number n has a factor f larger than the square root
X *     of n, then n/f must also be a factor and must be smaller
X *     than the square root of n.  Thus, it is sufficient to
X *     check only factors up to the square root.  For efficiency,
X *     the square root is calculated outside the loop.  To ensure
X *     that roundoff error in floating-point arithmetic does not
X *     cause us to miss a factor, this algorithm checks one
X *     extra value.
X */
X
Xbool IsPrime(int n)
X{
X    int i, limit;
X
X    if (n <= 1) return (FALSE);
X    if (n == 2) return (TRUE);
X    if (n % 2 == 0) return (FALSE);
X    limit = sqrt(n) + 1;
X    for (i = 3; i <= limit; i += 2) {
X        if (n % i == 0) return (FALSE);
X    }
X    return (TRUE);
X}
END_OF_FILE
if test 2151 -ne `wc -c <'programs/06-Algorithms/primes3.c'`; then
    echo shar: \"'programs/06-Algorithms/primes3.c'\" unpacked with wrong size!
fi
# end of 'programs/06-Algorithms/primes3.c'
fi
if test -f 'programs/06-Algorithms/tsqrt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/06-Algorithms/tsqrt.c'\"
else
echo shar: Extracting \"'programs/06-Algorithms/tsqrt.c'\" \(2570 characters\)
sed "s/^X//" >'programs/06-Algorithms/tsqrt.c' <<'END_OF_FILE'
X/*
X * File: tsqrt.c
X * -------------
X * This program calculates the square root function
X * using the Taylor series expansion.
X */
X
X#include <stdio.h>
X#include <float.h>
X#include <math.h>
X#include "genlib.h"
X
X/* Function prototypes */
X
Xvoid TestSqrt(double x);
Xdouble Sqrt(double x);
Xdouble TSqrt(double x);
X
X/* Main program */
X
Xmain()
X{
X    TestSqrt(0.0);
X    TestSqrt(0.25);
X    TestSqrt(1);
X    TestSqrt(2);
X    TestSqrt(3);
X    TestSqrt(4);
X    TestSqrt(49);
X    TestSqrt(200);
X    TestSqrt(1.0E10);
X}
X
X/*
X * Function: TestSqrt
X * Usage: TestSqrt(x);
X * -------------------
X * Generates a line of the test table.
X */
X
Xvoid TestSqrt(double x)
X{
X    printf("Sqrt(%g) = %g  sqrt(%g) = %g\n", x, Sqrt(x), x, sqrt(x));
X}
X
X/*
X * Function: Sqrt
X * Usage: root = Sqrt(x);
X * ----------------------
X * Returns the square root of x, calculated using a
X * Taylor series expansion, as described in the text.
X * The Sqrt function is actually implemented as two
X * functions.  The job of the outer Sqrt function is to
X * divide the argument repeatedly by 4 until it is in
X * the range 0 < x < 2, where the Taylor series converges.
X * It then calls TSqrt to perform the actual Taylor series
X * calculation.  When finished, Sqrt adjusts the answer by
X * multiplying the result by 2 for each time it needed to
X * be divided by 4 to bring it in range.
X */
X
Xdouble Sqrt(double x)
X{
X    double result, correction;
X
X    if (x == 0) return (0);
X    if (x < 0) Error("Sqrt called with negative argument %g", x);
X    correction = 1;
X    while (x >= 2) {
X        x /= 4;
X        correction *= 2;
X    }
X    return (TSqrt(x) * correction);
X}
X
X/*
X * Function: TSqrt
X * Usage: root = TSqrt(x);
X * -----------------------
X * Returns the square root of x, calculated by expanding
X * the Taylor series around a = 1, as described in the
X * text.  The function is effective only if x is in the
X * range 0 < x < 2.  Term i in the summation has the form
X *
X *                   xpower
X *       coeff  *  ---------
X *                 factorial
X *
X * where coeff comes from ith derivative of the function,
X * factorial is i!, and xpower is the ith power of (x - a).
X * Each of these components is computed from its previous
X * value.
X */
X
Xdouble TSqrt(double x)
X{
X    double sum, factorial, coeff, term, xpower;
X    int i;
X
X    factorial = coeff = xpower = 1;
X    sum = 0;
X    term = 1;
X    for (i = 0; sum != sum + term; i++) {
X        sum += term;
X        coeff *= (0.5 - i);
X        xpower *= (x - 1);
X        factorial *= (i + 1);
X        term = coeff * xpower / factorial;
X    }
X    return (sum);
X}
END_OF_FILE
if test 2570 -ne `wc -c <'programs/06-Algorithms/tsqrt.c'`; then
    echo shar: \"'programs/06-Algorithms/tsqrt.c'\" unpacked with wrong size!
fi
# end of 'programs/06-Algorithms/tsqrt.c'
fi
if test -f 'programs/06-Algorithms/zeno.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/06-Algorithms/zeno.c'\"
else
echo shar: Extracting \"'programs/06-Algorithms/zeno.c'\" \(499 characters\)
sed "s/^X//" >'programs/06-Algorithms/zeno.c' <<'END_OF_FILE'
X/*
X * File: zeno.c
X * ------------
X * This program calculates the sum of the infinite
X * series suggested by Zeno's paradox:
X *
X *       1     1     1     1     1     1
X *      --- + --- + --- + --- + --- + --- + ...
X *       2     4     8    16    32    64
X */
X
X#include <stdio.h>
X#include "genlib.h"
X
Xmain()
X{
X    double sum, term;
X
X    sum = 0.0;
X    term = 0.5;
X    while (sum != sum + term) {
X        sum += term;
X        term /= 2;
X    }
X    printf("The sum of Zeno's series is %g\n", sum);
X}
END_OF_FILE
if test 499 -ne `wc -c <'programs/06-Algorithms/zeno.c'`; then
    echo shar: \"'programs/06-Algorithms/zeno.c'\" unpacked with wrong size!
fi
# end of 'programs/06-Algorithms/zeno.c'
fi
if test -f 'programs/07-Graphics/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/07-Graphics/Makefile'\"
else
echo shar: Extracting \"'programs/07-Graphics/Makefile'\" \(1687 characters\)
sed "s/^X//" >'programs/07-Graphics/Makefile' <<'END_OF_FILE'
X# Makefile for cbook/07-Graphics/programs
X# Created by the ExportAll facility
X# ***************************************************************
X
XPROGRAMS = \
X    arc1 \
X    arc2 \
X    drawcirc \
X    drawcbox \
X    oneline \
X    drawbox \
X    house 
X
X# ***************************************************************
X# Parameters to control Makefile operation
X# Note that the gccx command script must be defined
X
XCC = gccx
XCFLAGS = 
X
X# ***************************************************************
X# Entry to bring the package up to date
X
Xall: $(PROGRAMS)
X
X# ***************************************************************
X# Standard entries to remove files from the directories
X#    tidy    -- eliminate unwanted files
X#    scratch -- delete derived files in preparation for rebuild
X
Xtidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
Xscratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
X# ***************************************************************
X# C compilations
X
Xarc1.o: arc1.c
X	$(CC) $(CFLAGS) -c arc1.c
X
Xarc2.o: arc2.c
X	$(CC) $(CFLAGS) -c arc2.c
X
Xdrawcirc.o: drawcirc.c
X	$(CC) $(CFLAGS) -c drawcirc.c
X
Xdrawcbox.o: drawcbox.c
X	$(CC) $(CFLAGS) -c drawcbox.c
X
Xoneline.o: oneline.c
X	$(CC) $(CFLAGS) -c oneline.c
X
Xdrawbox.o: drawbox.c
X	$(CC) $(CFLAGS) -c drawbox.c
X
Xhouse.o: house.c
X	$(CC) $(CFLAGS) -c house.c
X
X
Xarc1: arc1.o
X	$(CC) $(CFLAGS) -o arc1 arc1.o
X
Xarc2: arc2.o
X	$(CC) $(CFLAGS) -o arc2 arc2.o
X
Xdrawcirc: drawcirc.o
X	$(CC) $(CFLAGS) -o drawcirc drawcirc.o
X
Xdrawcbox: drawcbox.o
X	$(CC) $(CFLAGS) -o drawcbox drawcbox.o
X
Xoneline: oneline.o
X	$(CC) $(CFLAGS) -o oneline oneline.o
X
Xdrawbox: drawbox.o
X	$(CC) $(CFLAGS) -o drawbox drawbox.o
X
Xhouse: house.o
X	$(CC) $(CFLAGS) -o house house.o
END_OF_FILE
if test 1687 -ne `wc -c <'programs/07-Graphics/Makefile'`; then
    echo shar: \"'programs/07-Graphics/Makefile'\" unpacked with wrong size!
fi
# end of 'programs/07-Graphics/Makefile'
fi
if test -f 'programs/07-Graphics/arc1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/07-Graphics/arc1.c'\"
else
echo shar: Extracting \"'programs/07-Graphics/arc1.c'\" \(272 characters\)
sed "s/^X//" >'programs/07-Graphics/arc1.c' <<'END_OF_FILE'
X/*
X * File: arc1.c
X * ------------
X * This program is the first test of the DrawArc function
X * and draws a complete circle.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "graphics.h"
X
Xmain()
X{
X    InitGraphics();
X    MovePen(1.5, 1.0);
X    DrawArc(0.5, 0, 360);
X}
END_OF_FILE
if test 272 -ne `wc -c <'programs/07-Graphics/arc1.c'`; then
    echo shar: \"'programs/07-Graphics/arc1.c'\" unpacked with wrong size!
fi
# end of 'programs/07-Graphics/arc1.c'
fi
if test -f 'programs/07-Graphics/arc2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/07-Graphics/arc2.c'\"
else
echo shar: Extracting \"'programs/07-Graphics/arc2.c'\" \(274 characters\)
sed "s/^X//" >'programs/07-Graphics/arc2.c' <<'END_OF_FILE'
X/*
X * File: arc2.c
X * ------------
X * This program is the second test of the DrawArc function
X * and draws a left semicircle.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "graphics.h"
X
Xmain()
X{
X    InitGraphics();
X    MovePen(1.0, 1.5);
X    DrawArc(0.5, 90, 180);
X}
END_OF_FILE
if test 274 -ne `wc -c <'programs/07-Graphics/arc2.c'`; then
    echo shar: \"'programs/07-Graphics/arc2.c'\" unpacked with wrong size!
fi
# end of 'programs/07-Graphics/arc2.c'
fi
if test -f 'programs/07-Graphics/drawbox.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/07-Graphics/drawbox.c'\"
else
echo shar: Extracting \"'programs/07-Graphics/drawbox.c'\" \(726 characters\)
sed "s/^X//" >'programs/07-Graphics/drawbox.c' <<'END_OF_FILE'
X/*
X * File: drawbox.c
X * ---------------
X * This program draws a box on the screen.
X */
X
X#include <stdio.h>
X
X#include "genlib.h"
X#include "graphics.h"
X
X/* Function prototypes */
X
Xvoid DrawBox(double x, double y, double width, double height);
X
X/* Main program */
X
Xmain()
X{
X    InitGraphics();
X    DrawBox(0.5, 0.5, 1.0, 1.0);
X}
X
X/*
X * Function: DrawBox
X * Usage: DrawBox(x, y, width, height)
X * -----------------------------------
X * This function draws a rectangle of the given width and
X * height with its lower left corner at (x, y).
X */
X
Xvoid DrawBox(double x, double y, double width, double height)
X{
X    MovePen(x, y);
X    DrawLine(0, height);
X    DrawLine(width, 0);
X    DrawLine(0, -height);
X    DrawLine(-width, 0);
X}
END_OF_FILE
if test 726 -ne `wc -c <'programs/07-Graphics/drawbox.c'`; then
    echo shar: \"'programs/07-Graphics/drawbox.c'\" unpacked with wrong size!
fi
# end of 'programs/07-Graphics/drawbox.c'
fi
if test -f 'programs/07-Graphics/drawcbox.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/07-Graphics/drawcbox.c'\"
else
echo shar: Extracting \"'programs/07-Graphics/drawcbox.c'\" \(1282 characters\)
sed "s/^X//" >'programs/07-Graphics/drawcbox.c' <<'END_OF_FILE'
X/*
X * File: drawcbox.c
X * ----------------
X * Program to draw a centered box.
X */
X
X#include <stdio.h>
X
X#include "genlib.h"
X#include "graphics.h"
X
X/* Function prototypes */
X
Xvoid DrawBox(double x, double y, double width, double height);
Xvoid DrawCenteredBox(double x, double y,
X                     double width, double height);
X
X/* Main program */
X
Xmain()
X{
X    double cx, cy;
X
X    InitGraphics();
X    cx = GetWindowWidth() / 2;
X    cy = GetWindowHeight() / 2;
X    DrawCenteredBox(cx, cy, 2.0, 1.0);
X}
X
X/*
X * Function: DrawBox
X * Usage: DrawBox(x, y, width, height)
X * -----------------------------------
X * This function draws a rectangle of the given width and
X * height with its lower left corner at (x, y).
X */
X
Xvoid DrawBox(double x, double y, double width, double height)
X{
X    MovePen(x, y);
X    DrawLine(0, height);
X    DrawLine(width, 0);
X    DrawLine(0, -height);
X    DrawLine(-width, 0);
X}
X
X/*
X * Function: DrawCenteredBox
X * Usage: DrawCenteredBox(x, y, width, height)
X * -------------------------------------------
X * This function draws a rectangle of the given width and
X * height with its center at (x, y).
X */
X
Xvoid DrawCenteredBox(double x, double y,
X                     double width, double height)
X{
X    DrawBox(x - width / 2, y - height / 2, width, height);
X}
END_OF_FILE
if test 1282 -ne `wc -c <'programs/07-Graphics/drawcbox.c'`; then
    echo shar: \"'programs/07-Graphics/drawcbox.c'\" unpacked with wrong size!
fi
# end of 'programs/07-Graphics/drawcbox.c'
fi
if test -f 'programs/07-Graphics/drawcirc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/07-Graphics/drawcirc.c'\"
else
echo shar: Extracting \"'programs/07-Graphics/drawcirc.c'\" \(619 characters\)
sed "s/^X//" >'programs/07-Graphics/drawcirc.c' <<'END_OF_FILE'
X/*
X * File: drawcirc.c
X * ----------------
X * Program to draw a complete circle.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "graphics.h"
X
X/* Function prototypes */
X
Xvoid DrawCenteredCircle(double x, double y, double r);
X
X/* Main program */
X
Xmain()
X{
X    InitGraphics();
X    DrawCenteredCircle(1.0, 1.0, 0.5);
X}
X
X/*
X * Function: DrawCenteredCircle
X * Usage: DrawCenteredCircle(x, y, r);
X * -----------------------------------
X * This function draws a circle of radius r with its
X * center at (x, y).
X */
X
Xvoid DrawCenteredCircle(double x, double y, double r)
X{
X    MovePen(x + r, y);
X    DrawArc(r, 0, 360);
X}
END_OF_FILE
if test 619 -ne `wc -c <'programs/07-Graphics/drawcirc.c'`; then
    echo shar: \"'programs/07-Graphics/drawcirc.c'\" unpacked with wrong size!
fi
# end of 'programs/07-Graphics/drawcirc.c'
fi
if test -f 'programs/07-Graphics/house.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/07-Graphics/house.c'\"
else
echo shar: Extracting \"'programs/07-Graphics/house.c'\" \(5294 characters\)
sed "s/^X//" >'programs/07-Graphics/house.c' <<'END_OF_FILE'
X/*
X * File: house.c
X * -------------
X * This program draws a simple frame house.
X */
X
X#include <stdio.h>
X
X#include "genlib.h"
X#include "graphics.h"
X
X/*
X * Constants
X * ---------
X * The following constants control the sizes of the
X * various elements in the display.
X */
X
X#define HouseHeight         2.0
X#define HouseWidth          3.0
X#define AtticHeight         0.7
X
X#define DoorWidth           0.4
X#define DoorHeight          0.7
X#define DoorknobRadius      0.03
X#define DoorknobInset       0.07
X
X#define PaneHeight          0.25
X#define PaneWidth           0.2
X
X#define FirstFloorWindows   0.3
X#define SecondFloorWindows  1.25
X
X/* Function prototypes */
X
Xvoid DrawHouse(double x, double y);
Xvoid DrawOutline(double x, double y);
Xvoid DrawWindows(double x, double y);
Xvoid DrawDoor(double x, double y);
Xvoid DrawBox(double x, double y, double width, double height);
Xvoid DrawTriangle(double x, double y, double base, double height);
Xvoid DrawCenteredCircle(double x, double y, double r);
Xvoid DrawGrid(double x, double y, double width, double height,
X              int columns, int rows);
X
X/* Main program */
X
Xmain()
X{
X    double cx, cy;
X
X    InitGraphics();
X    cx = GetWindowWidth() / 2;
X    cy = GetWindowHeight() / 2;
X    DrawHouse(cx - HouseWidth / 2,
X              cy - (HouseHeight + AtticHeight) / 2);
X}
X
X/*
X * Function: DrawHouse
X * Usage: DrawHouse(x, y);
X * -----------------------
X * This function draws a house diagram with the lower left corner
X * at (x, y).  This level of the function merely divides up
X * the work.
X */
X
Xvoid DrawHouse(double x, double y)
X{
X    DrawOutline(x, y);
X    DrawDoor(x + (HouseWidth - DoorWidth) / 2, y);
X    DrawWindows(x, y);
X}
X
X/*
X * Function: DrawOutline
X * Usage: DrawOutline(x, y);
X * -------------------------
X * This function draws the outline for the house, using (x, y)
X * as the origin.  The outline consists of a box with a triangle
X * on top.
X */
X
Xvoid DrawOutline(double x, double y)
X{
X    DrawBox(x, y, HouseWidth, HouseHeight);
X    DrawTriangle(x, y + HouseHeight, HouseWidth, AtticHeight);
X}
X
X/*
X * Function: DrawDoor
X * Usage: DrawDoor(x, y);
X * ----------------------
X * This function draws a door, with its doorknob.  As usual,
X * (x, y) specifies the lower left corner of the door.
X */
X
Xvoid DrawDoor(double x, double y)
X{
X    DrawBox(x, y, DoorWidth, DoorHeight);
X    DrawCenteredCircle(x + DoorWidth - DoorknobInset,
X                       y + DoorHeight / 2, DoorknobRadius);
X}
X
X/*
X * Function: DrawWindows
X * Usage: DrawWindows(x, y);
X * -------------------------
X * This function draws all the windows for the house,
X * taking advantage of the fact that the windows are all
X * arranged in two-dimensional grids of equal-sized panes.
X * By calling the function DrawGrid, this implementation
X * can create all of the window structures using a single
X * tool.
X */
X
Xvoid DrawWindows(double x, double y)
X{
X    double xleft, xright;
X
X    xleft = x + HouseWidth * 0.25;
X    xright = x + HouseWidth * 0.75;
X    DrawGrid(xleft - PaneWidth * 1.5, y + FirstFloorWindows,
X             PaneWidth, PaneHeight, 3, 2);
X    DrawGrid(xright - PaneWidth * 1.5, y + FirstFloorWindows,
X             PaneWidth, PaneHeight, 3, 2);
X    DrawGrid(xleft - PaneWidth, y + SecondFloorWindows,
X             PaneWidth, PaneHeight, 2, 2);
X    DrawGrid(xright - PaneWidth, y + SecondFloorWindows,
X             PaneWidth, PaneHeight, 2, 2);
X}
X
X/*
X * Function: DrawBox
X * Usage: DrawBox(x, y, width, height)
X * -----------------------------------
X * This function draws a rectangle of the given width and
X * height with its lower left corner at (x, y).
X */
X
Xvoid DrawBox(double x, double y, double width, double height)
X{
X    MovePen(x, y);
X    DrawLine(0, height);
X    DrawLine(width, 0);
X    DrawLine(0, -height);
X    DrawLine(-width, 0);
X}
X
X/*
X * Function: DrawTriangle
X * Usage: DrawTriangle(x, y, base, height)
X * ---------------------------------------
X * This function draws an isosceles triangle (i.e., one with
X * two equal sides) with a horizontal base.  The coordinate of
X * the left endpoint of the base is (x, y), and the triangle
X * has the indicated base length and height.  If height is
X * positive, the triangle points upward.  If height is negative,
X * the triangle points downward.
X */
X
Xvoid DrawTriangle(double x, double y, double base, double height)
X{
X    MovePen(x, y);
X    DrawLine(base, 0);
X    DrawLine(-base / 2, height);
X    DrawLine(-base / 2, -height);
X}
X
X/*
X * Function: DrawCenteredCircle
X * Usage: DrawCenteredCircle(x, y, r);
X * -----------------------------------
X * This function draws a circle of radius r with its
X * center at (x, y).
X */
X
Xvoid DrawCenteredCircle(double x, double y, double r)
X{
X    MovePen(x + r, y);
X    DrawArc(r, 0, 360);
X}
X
X/*
X * Function: DrawGrid
X * Usage: DrawGrid(x, y, width, height, columns, rows);
X * ----------------------------------------------------
X * DrawGrid draws rectangles arranged in a two-dimensional
X * grid.  As always, (x, y) specifies the lower left corner
X * of the figure.
X */
X
Xvoid DrawGrid(double x, double y, double width, double height,
X              int columns, int rows)
X{
X    int i, j;
X
X    for (i = 0; i < columns; i++) {
X        for (j = 0; j < rows; j++) {
X            DrawBox(x + i * width, y + j * height,
X                    width, height);
X        }
X    }
X}
END_OF_FILE
if test 5294 -ne `wc -c <'programs/07-Graphics/house.c'`; then
    echo shar: \"'programs/07-Graphics/house.c'\" unpacked with wrong size!
fi
# end of 'programs/07-Graphics/house.c'
fi
if test -f 'programs/07-Graphics/oneline.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/07-Graphics/oneline.c'\"
else
echo shar: Extracting \"'programs/07-Graphics/oneline.c'\" \(233 characters\)
sed "s/^X//" >'programs/07-Graphics/oneline.c' <<'END_OF_FILE'
X/*
X * File: oneline.c
X * ---------------
X * This program draws a single straight line.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "graphics.h"
X
Xmain()
X{
X    InitGraphics();
X    MovePen(0.5, 0.5);
X    DrawLine(0.0, 1.0);
X}
X
END_OF_FILE
if test 233 -ne `wc -c <'programs/07-Graphics/oneline.c'`; then
    echo shar: \"'programs/07-Graphics/oneline.c'\" unpacked with wrong size!
fi
# end of 'programs/07-Graphics/oneline.c'
fi
if test -f 'programs/08-Random-Numbers/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/08-Random-Numbers/Makefile'\"
else
echo shar: Extracting \"'programs/08-Random-Numbers/Makefile'\" \(1377 characters\)
sed "s/^X//" >'programs/08-Random-Numbers/Makefile' <<'END_OF_FILE'
X# Makefile for cbook/08-Random-Numbers/programs
X# Created by the ExportAll facility
X# ***************************************************************
X
XPROGRAMS = \
X    randtest \
X    cointest \
X    dicetest \
X    craps 
X
X# ***************************************************************
X# Parameters to control Makefile operation
X# Note that the gccx command script must be defined
X
XCC = gccx
XCFLAGS = 
X
X# ***************************************************************
X# Entry to bring the package up to date
X
Xall: $(PROGRAMS)
X
X# ***************************************************************
X# Standard entries to remove files from the directories
X#    tidy    -- eliminate unwanted files
X#    scratch -- delete derived files in preparation for rebuild
X
Xtidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
Xscratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
X# ***************************************************************
X# C compilations
X
Xrandtest.o: randtest.c
X	$(CC) $(CFLAGS) -c randtest.c
X
Xcointest.o: cointest.c
X	$(CC) $(CFLAGS) -c cointest.c
X
Xdicetest.o: dicetest.c
X	$(CC) $(CFLAGS) -c dicetest.c
X
Xcraps.o: craps.c
X	$(CC) $(CFLAGS) -c craps.c
X
X
Xrandtest: randtest.o
X	$(CC) $(CFLAGS) -o randtest randtest.o
X
Xcointest: cointest.o
X	$(CC) $(CFLAGS) -o cointest cointest.o
X
Xdicetest: dicetest.o
X	$(CC) $(CFLAGS) -o dicetest dicetest.o
X
Xcraps: craps.o
X	$(CC) $(CFLAGS) -o craps craps.o
END_OF_FILE
if test 1377 -ne `wc -c <'programs/08-Random-Numbers/Makefile'`; then
    echo shar: \"'programs/08-Random-Numbers/Makefile'\" unpacked with wrong size!
fi
# end of 'programs/08-Random-Numbers/Makefile'
fi
if test -f 'programs/08-Random-Numbers/cointest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/08-Random-Numbers/cointest.c'\"
else
echo shar: Extracting \"'programs/08-Random-Numbers/cointest.c'\" \(448 characters\)
sed "s/^X//" >'programs/08-Random-Numbers/cointest.c' <<'END_OF_FILE'
X/*
X * File: cointest.c
X * ----------------
X * This program simulates flipping a coin.
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include "genlib.h"
X
X/*
X * Constants
X * ---------
X * NTrials -- Number of trials
X */
X
X#define NTrials 10
X
X/* Main program */
X
Xmain()
X{
X    int i;
X
X    for (i = 0; i < NTrials; i++) {
X        if (rand() <= RAND_MAX / 2) {
X            printf("Heads\n");
X        } else {
X            printf("Tails\n");
X        }
X    }
X}
END_OF_FILE
if test 448 -ne `wc -c <'programs/08-Random-Numbers/cointest.c'`; then
    echo shar: \"'programs/08-Random-Numbers/cointest.c'\" unpacked with wrong size!
fi
# end of 'programs/08-Random-Numbers/cointest.c'
fi
if test -f 'programs/08-Random-Numbers/craps.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/08-Random-Numbers/craps.c'\"
else
echo shar: Extracting \"'programs/08-Random-Numbers/craps.c'\" \(3469 characters\)
sed "s/^X//" >'programs/08-Random-Numbers/craps.c' <<'END_OF_FILE'
X/*
X * File: craps.c
X * -------------
X * This program plays the dice game called craps.  For a discussion
X * of the rules of craps, please see the GiveInstructions function.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "random.h"
X#include "simpio.h"
X#include "strlib.h"
X
X/* Function prototypes */
X
Xvoid GiveInstructions(void);
Xvoid PlayCrapsGame(void);
Xint RollTwoDice(void);
Xbool GetYesOrNo(string prompt);
X
X/* Main program */
X
Xmain()
X{
X    Randomize();
X    if (GetYesOrNo("Would you like instructions? ")) {
X        GiveInstructions();
X    }
X    while (TRUE) {
X        PlayCrapsGame();
X        if (!GetYesOrNo("Would you like to play again? ")) break;
X    }
X}
X
X/*
X * Function: GiveInstructions
X * Usage: GiveInstructions();
X * -----------------------
X * This function welcomes the player to the game and gives
X * instructions on the rules to craps.
X */
X
Xvoid GiveInstructions(void)
X{
X    printf("Welcome to the craps table!\n\n");
X    printf("To play craps, you start by rolling a pair of dice\n");
X    printf("and looking at the total.  If the total is 2, 3, or\n");
X    printf("12, that's called 'crapping out' and you lose.  If\n");
X    printf("you roll a 7 or an 11, that's called a 'natural' and\n");
X    printf("you win.  If you roll any other number, that number\n");
X    printf("becomes your 'point' and you keep on rolling until\n");
X    printf("you roll your point again (in which case you win)\n");
X    printf("or a 7 (in which case you lose).\n");
X}
X
X/*
X * Function: PlayCrapsGame
X * Usage: PlayCrapsGame();
X * -----------------------
X * This function plays one game of craps.
X */
X
Xvoid PlayCrapsGame(void)
X{
X    int total, point;
X
X    printf("\nHere we go!\n");
X    total = RollTwoDice();
X    if (total == 7 || total == 11) {
X        printf("That's a natural.  You win.\n");
X    } else if (total == 2 || total == 3 || total == 12) {
X        printf("That's craps.  You lose.\n");
X    } else {
X        point = total;
X        printf("Your point is %d.\n", point);
X        while (TRUE) {
X            total = RollTwoDice();
X            if (total == point) {
X                printf("You made your point.  You win.\n");
X                break;
X            } else if (total == 7) {
X                printf("That's a seven.  You lose.\n");
X                break;
X            }
X        }
X    }
X}
X
X/*
X * Function: RollTwoDice
X * Usage: total = RollTwoDice();
X * -----------------------------
X * This function rolls two dice and returns their sum.  As part
X * of the implementation, the result is displayed on the screen.
X */
X
Xint RollTwoDice(void)
X{
X    int d1, d2, total;
X
X    printf("Rolling the dice . . .\n");
X    d1 = RandomInteger(1, 6);
X    d2 = RandomInteger(1, 6);
X    total = d1 + d2;
X    printf("You rolled %d and %d -- that's %d.\n", d1, d2, total);
X    return (total);
X}
X
X/*
X * Function: GetYesOrNo
X * Usage: if (GetYesOrNo(prompt)) . . .
X * ------------------------------------
X * This function asks the user the question indicated by prompt
X * and waits for a yes/no response.  If the user answers "yes"
X * or "no", the program returns TRUE or FALSE accordingly.
X * If the user gives any other response, the program asks
X * the question again.
X */
X
Xbool GetYesOrNo(string prompt)
X{
X    string answer;
X
X    while (TRUE) {
X        printf("%s", prompt);
X        answer = GetLine();
X        if (StringEqual(answer, "yes")) return (TRUE);
X        if (StringEqual(answer, "no")) return (FALSE);
X        printf("Please answer yes or no.\n");
X    }
X}
X
X
END_OF_FILE
if test 3469 -ne `wc -c <'programs/08-Random-Numbers/craps.c'`; then
    echo shar: \"'programs/08-Random-Numbers/craps.c'\" unpacked with wrong size!
fi
# end of 'programs/08-Random-Numbers/craps.c'
fi
if test -f 'programs/08-Random-Numbers/dicetest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/08-Random-Numbers/dicetest.c'\"
else
echo shar: Extracting \"'programs/08-Random-Numbers/dicetest.c'\" \(663 characters\)
sed "s/^X//" >'programs/08-Random-Numbers/dicetest.c' <<'END_OF_FILE'
X/*
X * File: dicetest.c
X * ----------------
X * This program simulates rolling a die.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "random.h"
X
X/*
X * Constants
X * ---------
X * NTrials -- Number of trials
X */
X
X#define NTrials 10
X
X/* Function prototypes */
X
Xint RollDie(void);
X
X/* Main program */
X
Xmain()
X{
X    int i;
X
X    for (i = 0; i < NTrials; i++) {
X        printf("%d\n", RollDie());
X    }
X}
X
X/*
X * Function: RollDie
X * Usage: die = RollDie();
X * -----------------------
X * This function generates and returns a random integer in the
X * range 1 to 6, representing the roll of a six-sided die.
X */
X
Xint RollDie(void)
X{
X    return (RandomInteger(1, 6));
X}
END_OF_FILE
if test 663 -ne `wc -c <'programs/08-Random-Numbers/dicetest.c'`; then
    echo shar: \"'programs/08-Random-Numbers/dicetest.c'\" unpacked with wrong size!
fi
# end of 'programs/08-Random-Numbers/dicetest.c'
fi
if test -f 'programs/08-Random-Numbers/random.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/08-Random-Numbers/random.c'\"
else
echo shar: Extracting \"'programs/08-Random-Numbers/random.c'\" \(1653 characters\)
sed "s/^X//" >'programs/08-Random-Numbers/random.c' <<'END_OF_FILE'
X/*
X * File: random.c
X * Last modified on Mon Sep 13 10:42:45 1993 by eroberts
X * --------------
X * Implements the random.h interface.
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <time.h>
X
X#include "genlib.h"
X#include "random.h"
X
X/*
X * Function: Randomize
X * -------------------
X * This function operates by setting the random number
X * seed to the current time.  The srand function is
X * provided by the <stdlib.h> library and requires an
X * integer argument.  The time function is provided
X * by <time.h>.
X */
X
Xvoid Randomize(void)
X{
X    srand((int) time(NULL));
X}
X
X/*
X * Function: RandomInteger
X * -----------------------
X * This function first obtains a random integer in
X * the range [0..RAND_MAX] by applying four steps:
X * (1) Generate a real number between 0 and 1.
X * (2) Scale it to the appropriate range size.
X * (3) Truncate the value to an integer.
X * (4) Translate it to the appropriate starting point.
X */
X
Xint RandomInteger(int low, int high)
X{
X    int k;
X    double d;
X
X    d = (double) rand() / ((double) RAND_MAX + 1);
X    k = (int) (d * (high - low + 1));
X    return (low + k);
X}
X
X/*
X * Function: RandomReal
X * --------------------
X * The implementation of RandomReal is similar to that
X * of RandomInteger, without the truncation step.
X */
X
Xdouble RandomReal(double low, double high)
X{
X    double d;
X
X    d = (double) rand() / ((double) RAND_MAX + 1);
X    return (low + d * (high - low));
X}
X
X/*
X * Function: RandomChance
X * ----------------------
X * This function uses RandomReal to generate a number
X * between 0 and 100, which it then compares to p.
X */
X
Xbool RandomChance(double p)
X{
X    return (RandomReal(0, 1) < p);
X}
END_OF_FILE
if test 1653 -ne `wc -c <'programs/08-Random-Numbers/random.c'`; then
    echo shar: \"'programs/08-Random-Numbers/random.c'\" unpacked with wrong size!
fi
# end of 'programs/08-Random-Numbers/random.c'
fi
if test -f 'programs/08-Random-Numbers/random.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/08-Random-Numbers/random.h'\"
else
echo shar: Extracting \"'programs/08-Random-Numbers/random.h'\" \(1490 characters\)
sed "s/^X//" >'programs/08-Random-Numbers/random.h' <<'END_OF_FILE'
X/*
X * File: random.h
X * Last modified on Mon Sep 13 10:42:45 1993 by eroberts
X * --------------
X * Library package to produce pseudo-random numbers.
X */
X
X#ifndef _random_h
X#define _random_h
X
X#include "genlib.h"
X
X/*
X * Function: Randomize
X * Usage: Randomize();
X * -------------------
X * This function sets the random seed so that the random
X * sequence is unpredictable.  During the debugging phase,
X * it is best not to call this function, so that program
X * behavior is repeatable.
X */
X
Xvoid Randomize(void);
X
X/*
X * Function: RandomInteger
X * Usage: n = RandomInteger(low, high);
X * ------------------------------------
X * This function returns a random integer in the range
X * low to high, inclusive.
X */
X
Xint RandomInteger(int low, int high);
X
X/*
X * Function: RandomReal
X * Usage: d = RandomReal(low, high);
X * ---------------------------------
X * This function returns a random real number in the
X * half-open interval [low .. high), meaning that the
X * result is always greater than or equal to low but
X * strictly less than high.
X */
X
Xdouble RandomReal(double low, double high);
X
X/*
X * Function: RandomChance
X * Usage: if (RandomChance(p)) . . .
X * ---------------------------------
X * The RandomChance function returns TRUE with the probability
X * indicated by p, which should be a floating-point number
X * between 0 (meaning never) and 1 (meaning always).  For
X * example, calling RandomChance(.30) returns TRUE 30 percent
X * of the time.
X */
X
Xbool RandomChance(double p);
X
X#endif
END_OF_FILE
if test 1490 -ne `wc -c <'programs/08-Random-Numbers/random.h'`; then
    echo shar: \"'programs/08-Random-Numbers/random.h'\" unpacked with wrong size!
fi
# end of 'programs/08-Random-Numbers/random.h'
fi
if test -f 'programs/08-Random-Numbers/randtest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/08-Random-Numbers/randtest.c'\"
else
echo shar: Extracting \"'programs/08-Random-Numbers/randtest.c'\" \(504 characters\)
sed "s/^X//" >'programs/08-Random-Numbers/randtest.c' <<'END_OF_FILE'
X/*
X * File: randtest.c
X * ----------------
X * This program tests the ANSI rand function.
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include "genlib.h"
X
X/*
X * Constants
X * ---------
X * NTrials -- Number of trials
X */
X
X#define NTrials 10
X
X/* Main program */
X
Xmain()
X{
X    int i, r;
X
X    printf("On this computer, RAND_MAX = %d.\n", RAND_MAX);
X    printf("Here are the results of %d calls to rand:\n", NTrials);
X    for (i = 0; i < NTrials; i++) {
X        r = rand();
X        printf("%10d\n", r);
X    }
X}
END_OF_FILE
if test 504 -ne `wc -c <'programs/08-Random-Numbers/randtest.c'`; then
    echo shar: \"'programs/08-Random-Numbers/randtest.c'\" unpacked with wrong size!
fi
# end of 'programs/08-Random-Numbers/randtest.c'
fi
if test -f 'programs/09-Strings/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/09-Strings/Makefile'\"
else
echo shar: Extracting \"'programs/09-Strings/Makefile'\" \(1998 characters\)
sed "s/^X//" >'programs/09-Strings/Makefile' <<'END_OF_FILE'
X# Makefile for cbook/09-Strings/programs
X# Created by the ExportAll facility
X# ***************************************************************
X
XPROGRAMS = \
X    acronym \
X    addlist \
X    lastchar \
X    linelen \
X    ncopies \
X    protect \
X    reverse \
X    secondh \
X    repfirst 
X
X# ***************************************************************
X# Parameters to control Makefile operation
X# Note that the gccx command script must be defined
X
XCC = gccx
XCFLAGS = 
X
X# ***************************************************************
X# Entry to bring the package up to date
X
Xall: $(PROGRAMS)
X
X# ***************************************************************
X# Standard entries to remove files from the directories
X#    tidy    -- eliminate unwanted files
X#    scratch -- delete derived files in preparation for rebuild
X
Xtidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
Xscratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
X# ***************************************************************
X# C compilations
X
Xacronym.o: acronym.c
X	$(CC) $(CFLAGS) -c acronym.c
X
Xaddlist.o: addlist.c
X	$(CC) $(CFLAGS) -c addlist.c
X
Xlastchar.o: lastchar.c
X	$(CC) $(CFLAGS) -c lastchar.c
X
Xlinelen.o: linelen.c
X	$(CC) $(CFLAGS) -c linelen.c
X
Xncopies.o: ncopies.c
X	$(CC) $(CFLAGS) -c ncopies.c
X
Xprotect.o: protect.c
X	$(CC) $(CFLAGS) -c protect.c
X
Xreverse.o: reverse.c
X	$(CC) $(CFLAGS) -c reverse.c
X
Xsecondh.o: secondh.c
X	$(CC) $(CFLAGS) -c secondh.c
X
Xrepfirst.o: repfirst.c
X	$(CC) $(CFLAGS) -c repfirst.c
X
X
Xacronym: acronym.o
X	$(CC) $(CFLAGS) -o acronym acronym.o
X
Xaddlist: addlist.o
X	$(CC) $(CFLAGS) -o addlist addlist.o
X
Xlastchar: lastchar.o
X	$(CC) $(CFLAGS) -o lastchar lastchar.o
X
Xlinelen: linelen.o
X	$(CC) $(CFLAGS) -o linelen linelen.o
X
Xncopies: ncopies.o
X	$(CC) $(CFLAGS) -o ncopies ncopies.o
X
Xprotect: protect.o
X	$(CC) $(CFLAGS) -o protect protect.o
X
Xreverse: reverse.o
X	$(CC) $(CFLAGS) -o reverse reverse.o
X
Xsecondh: secondh.o
X	$(CC) $(CFLAGS) -o secondh secondh.o
X
Xrepfirst: repfirst.o
X	$(CC) $(CFLAGS) -o repfirst repfirst.o
END_OF_FILE
if test 1998 -ne `wc -c <'programs/09-Strings/Makefile'`; then
    echo shar: \"'programs/09-Strings/Makefile'\" unpacked with wrong size!
fi
# end of 'programs/09-Strings/Makefile'
fi
if test -f 'programs/09-Strings/acronym.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/09-Strings/acronym.c'\"
else
echo shar: Extracting \"'programs/09-Strings/acronym.c'\" \(1339 characters\)
sed "s/^X//" >'programs/09-Strings/acronym.c' <<'END_OF_FILE'
X/*
X * File: acronym.c
X * ---------------
X * Implements and tests the Acronym function.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X#include "strlib.h"
X
X/* Function prototypes */
X
Xstring Acronym(string str);
X
X/* Main program */
X
Xmain()
X{
X    string str;
X
X    printf("This program generates acronyms.\n");
X    printf("Indicate end of input with a blank line.\n");
X    while (TRUE) {
X        printf("String: ");
X        str = GetLine();
X        if (StringEqual(str, "")) break;
X        printf("The acronym is %s.\n", Acronym(str));
X    }
X}
X
X/*
X * Function: Acronym
X * Usage: acronym = Acronym(str);
X * ------------------------------
X * Takes a string consisting of a sequence of words and returns
X * the acronym formed by taking the initial letter of each word.
X * The program operates by finding each space in the word and
X * then concatenating the following letter onto the acronym so
X * far.  At the beginning, the acronym is set to be the first
X * character in the string.
X */
X
Xstring Acronym(string str)
X{
X    string acronym;
X    int pos;
X
X    acronym = CharToString(IthChar(str, 0));
X    pos = 0;
X    while (TRUE) {
X        pos = FindChar(' ', str, pos + 1);
X        if (pos == -1) break;
X        acronym = Concat(acronym,
X                         CharToString(IthChar(str, pos + 1)));
X    }
X    return (acronym);
X}
END_OF_FILE
if test 1339 -ne `wc -c <'programs/09-Strings/acronym.c'`; then
    echo shar: \"'programs/09-Strings/acronym.c'\" unpacked with wrong size!
fi
# end of 'programs/09-Strings/acronym.c'
fi
if test -f 'programs/09-Strings/addlist.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/09-Strings/addlist.c'\"
else
echo shar: Extracting \"'programs/09-Strings/addlist.c'\" \(614 characters\)
sed "s/^X//" >'programs/09-Strings/addlist.c' <<'END_OF_FILE'
X/*
X * File: addlist.c
X * ---------------
X * This program adds a list of numbers.  The end of the input
X * is indicated by entering a blank line as a sentinel value.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X#include "strlib.h"
X
Xmain()
X{
X    int total;
X    string line;
X
X    printf("This program adds a list of numbers.\n");
X    printf("Signal end of list with a blank line.\n");
X    total = 0;
X    while (TRUE) {
X        printf(" ? ");
X        line = GetLine();
X        if (StringEqual(line, "")) break;
X        total += StringToInteger(line);
X    }
X    printf("The total is %d\n", total);
X}
END_OF_FILE
if test 614 -ne `wc -c <'programs/09-Strings/addlist.c'`; then
    echo shar: \"'programs/09-Strings/addlist.c'\" unpacked with wrong size!
fi
# end of 'programs/09-Strings/addlist.c'
fi
if test -f 'programs/09-Strings/lastchar.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/09-Strings/lastchar.c'\"
else
echo shar: Extracting \"'programs/09-Strings/lastchar.c'\" \(891 characters\)
sed "s/^X//" >'programs/09-Strings/lastchar.c' <<'END_OF_FILE'
X/*
X * File: lastchar.c
X * ----------------
X * This file defines the function LastChar, which returns the
X * last character in a string.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "strlib.h"
X#include "simpio.h"
X
X/* Function prototypes */
X
Xchar LastChar(string str);
X
X/* Main program */
X
Xmain()
X{
X    string str;
X
X    printf("This program displays the last character in a string.\n");
X    printf("Enter a string: ");
X    str = GetLine();
X    printf("The last character is '%c'\n", LastChar(str));
X}
X
X/*
X * Function: LastChar
X * Usage: ch = LastChar(str);
X * --------------------------
X * This function returns the last character in the string str.
X * If LastChar is called on the empty string, an error condition
X * is reported because the IthChar function performs range
X * checking on the index.
X */
X
Xchar LastChar(string str)
X{
X    return (IthChar(str, StringLength(str) - 1));
X}
END_OF_FILE
if test 891 -ne `wc -c <'programs/09-Strings/lastchar.c'`; then
    echo shar: \"'programs/09-Strings/lastchar.c'\" unpacked with wrong size!
fi
# end of 'programs/09-Strings/lastchar.c'
fi
if test -f 'programs/09-Strings/linelen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/09-Strings/linelen.c'\"
else
echo shar: Extracting \"'programs/09-Strings/linelen.c'\" \(426 characters\)
sed "s/^X//" >'programs/09-Strings/linelen.c' <<'END_OF_FILE'
X/*
X * File: linelen.c
X * ---------------
X * This file contains a main program that reports the
X * length of an input line.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "strlib.h"
X#include "simpio.h"
X
X/* Main program */
X
Xmain()
X{
X    string str;
X
X    printf("This program tests the StringLength function.\n");
X    printf("Enter a string: ");
X    str = GetLine();
X    printf("The length is %d.\n", StringLength(str));
X}
END_OF_FILE
if test 426 -ne `wc -c <'programs/09-Strings/linelen.c'`; then
    echo shar: \"'programs/09-Strings/linelen.c'\" unpacked with wrong size!
fi
# end of 'programs/09-Strings/linelen.c'
fi
if test -f 'programs/09-Strings/ncopies.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/09-Strings/ncopies.c'\"
else
echo shar: Extracting \"'programs/09-Strings/ncopies.c'\" \(1097 characters\)
sed "s/^X//" >'programs/09-Strings/ncopies.c' <<'END_OF_FILE'
X/*
X * File: ncopies.c
X * ---------------
X * This file defines the function ConcatNCopies(n, str),
X * which returns a string consisting of n copies of the
X * argument str concatenated together.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "strlib.h"
X
X/* Function prototypes */
X
Xstring ConcatNCopies(int n, string str);
X
X/* Main program */
X
Xmain()
X{
X    printf("The next line could be used as a section divider.\n");
X    printf("%s\n", ConcatNCopies(25, "- "));
X}
X
X/*
X * Function: ConcatNCopies
X * Usage: newstr = ConcatNCopies(n, str);
X * --------------------------------------
X * This function creates a new string consisting of n
X * copies of str concatenated together.  For example,
X * the call ConcatNCopies(4, "AB") returns the string
X * "ABABABAB".  This implementation is quite inefficient,
X * both in its running time and use of memory, and should
X * not be used in practical applications.
X */
X
Xstring ConcatNCopies(int n, string str)
X{
X    string result;
X    int i;
X
X    result = "";
X    for (i = 0; i < n; i++) {
X        result = Concat(result, str);
X    }
X    return (result);
X}
END_OF_FILE
if test 1097 -ne `wc -c <'programs/09-Strings/ncopies.c'`; then
    echo shar: \"'programs/09-Strings/ncopies.c'\" unpacked with wrong size!
fi
# end of 'programs/09-Strings/ncopies.c'
fi
if test -f 'programs/09-Strings/protect.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/09-Strings/protect.c'\"
else
echo shar: Extracting \"'programs/09-Strings/protect.c'\" \(1369 characters\)
sed "s/^X//" >'programs/09-Strings/protect.c' <<'END_OF_FILE'
X/*
X * File: protect.c
X * ---------------
X * This file defines the function ProtectedIntegerField,
X * which might be useful in a financial application, in
X * which it was important to guard against having someone
X * forge extra digits at the beginning of a number.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "strlib.h"
X
X/* Function prototypes */
X
Xstring ProtectedIntegerField(int n, int places);
Xstring ConcatNCopies(int n, string str);
X
X/* Main program */
X
Xmain()
X{
X    printf("$%s.00\n", ProtectedIntegerField(123, 8));
X}
X
Xstring ProtectedIntegerField(int n, int places)
X{
X    string numstr, fill;
X
X    numstr = IntegerToString(n);
X    fill = ConcatNCopies(places - StringLength(numstr), "*");
X    return (Concat(fill, numstr));
X}
X
X/*
X * Function: ConcatNCopies
X * Usage: newstr = ConcatNCopies(n, str);
X * --------------------------------------
X * This function creates a new string consisting of n
X * copies of str concatenated together.  For example,
X * the call ConcatNCopies(4, "AB") returns the string
X * "ABABABAB".  This implementation is quite inefficient,
X * both in its running time and use of memory, and should
X * not be used in practical applications.
X */
X
Xstring ConcatNCopies(int n, string str)
X{
X    string result;
X    int i;
X
X    result = "";
X    for (i = 0; i < n; i++) {
X        result = Concat(result, str);
X    }
X    return (result);
X}
END_OF_FILE
if test 1369 -ne `wc -c <'programs/09-Strings/protect.c'`; then
    echo shar: \"'programs/09-Strings/protect.c'\" unpacked with wrong size!
fi
# end of 'programs/09-Strings/protect.c'
fi
if test -f 'programs/09-Strings/repfirst.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/09-Strings/repfirst.c'\"
else
echo shar: Extracting \"'programs/09-Strings/repfirst.c'\" \(1511 characters\)
sed "s/^X//" >'programs/09-Strings/repfirst.c' <<'END_OF_FILE'
X/*
X * File: repfirst.c
X * ----------------
X * This file implements and tests the function ReplaceFirst.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "strlib.h"
X#include "simpio.h"
X
X/* Function prototypes */
X
Xstring ReplaceFirst(string str, string pattern, string replacement);
X
X/* Main program */
X
Xmain()
X{
X    string str, pattern, replacement;
X
X    printf("This program edits a string by replacing the first\n");
X    printf("instance of a pattern substring by a new string.\n");
X    printf("Enter the string to be edited:\n");
X    str = GetLine();
X    printf("Enter the pattern string: ");
X    pattern = GetLine();
X    printf("Enter the replacement string: ");
X    replacement = GetLine();
X    str = ReplaceFirst(str, pattern, replacement);
X    printf("%s\n", str);
X}
X
X/*
X * Function: ReplaceFirst
X * Usage: newstr = ReplaceFirst(str, pattern, replacement);
X * --------------------------------------------------------
X * This function searches through the string str and replaces the
X * first instance of the pattern with the specified replacement.
X * If the pattern string does not appear, str is returned unchanged.
X */
X
Xstring ReplaceFirst(string str, string pattern, string replacement)
X{
X    string head, tail;
X    int pos;
X
X    pos = FindString(pattern, str, 0);
X    if (pos == -1) return (str);
X    head = SubString(str, 0, pos - 1);
X    tail = SubString(str, pos + StringLength(pattern),
X                          StringLength(str) - 1);
X    return (Concat(Concat(head, replacement), tail));
X}
END_OF_FILE
if test 1511 -ne `wc -c <'programs/09-Strings/repfirst.c'`; then
    echo shar: \"'programs/09-Strings/repfirst.c'\" unpacked with wrong size!
fi
# end of 'programs/09-Strings/repfirst.c'
fi
if test -f 'programs/09-Strings/reverse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/09-Strings/reverse.c'\"
else
echo shar: Extracting \"'programs/09-Strings/reverse.c'\" \(880 characters\)
sed "s/^X//" >'programs/09-Strings/reverse.c' <<'END_OF_FILE'
X/*
X * File: reverse.c
X * ---------------
X * This file defines the function ReverseString(str),
X * which returns str with its characters reversed.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "strlib.h"
X#include "simpio.h"
X
X/* Function prototypes */
X
Xstring ReverseString(string str);
X
X/* Main program */
X
Xmain()
X{
X    string str;
X
X    printf("Enter a string: ");
X    str = GetLine();
X    printf("\"%s\" backwards is \"%s\"\n", str, ReverseString(str));
X}
X
X/*
X * Function: ReverseString
X * Usage: newstr = ReverseString(str);
X * -----------------------------------
X * Returns a new string consisting of the characters in
X * str in reverse order.
X */
X
Xstring ReverseString(string str)
X{
X    string result;
X    int i;
X
X    result = "";
X    for (i = 0; i < StringLength(str); i++) {
X        result = Concat(CharToString(IthChar(str, i)), result);
X    }
X    return (result);
X}
END_OF_FILE
if test 880 -ne `wc -c <'programs/09-Strings/reverse.c'`; then
    echo shar: \"'programs/09-Strings/reverse.c'\" unpacked with wrong size!
fi
# end of 'programs/09-Strings/reverse.c'
fi
if test -f 'programs/09-Strings/secondh.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/09-Strings/secondh.c'\"
else
echo shar: Extracting \"'programs/09-Strings/secondh.c'\" \(868 characters\)
sed "s/^X//" >'programs/09-Strings/secondh.c' <<'END_OF_FILE'
X/*
X * File: secondh.c
X * ---------------
X * This file defines the function SecondHalf(str),
X * which returns the second half of its argument.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "strlib.h"
X#include "simpio.h"
X
X/* Function prototypes */
X
Xstring SecondHalf(string str);
X
X/* Main program */
X
Xmain()
X{
X    string str;
X
X    printf("Enter a string: ");
X    str = GetLine();
X    printf("The second half of \"%s\" is \"%s\"\n", str,
X           SecondHalf(str));
X}
X
X/*
X * Function: SecondHalf
X * Usage: newstr = SecondHalf(str);
X * --------------------------------
X * This function returns the second half of the string str.
X * If the string contains an odd number of characters, the
X * center character is included in the result.
X */
X
Xstring SecondHalf(string str)
X{
X    int len;
X
X    len = StringLength(str);
X    return (SubString(str, len / 2, len - 1));
X}
END_OF_FILE
if test 868 -ne `wc -c <'programs/09-Strings/secondh.c'`; then
    echo shar: \"'programs/09-Strings/secondh.c'\" unpacked with wrong size!
fi
# end of 'programs/09-Strings/secondh.c'
fi
if test -f 'programs/10-Modular-Development/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/10-Modular-Development/Makefile'\"
else
echo shar: Extracting \"'programs/10-Modular-Development/Makefile'\" \(1102 characters\)
sed "s/^X//" >'programs/10-Modular-Development/Makefile' <<'END_OF_FILE'
X# Makefile for cbook/10-Modular-Development/programs
X# Created by the ExportAll facility
X# ***************************************************************
X
XPROGRAMS = \
X    piglatin 
X
X# ***************************************************************
X# Parameters to control Makefile operation
X# Note that the gccx command script must be defined
X
XCC = gccx
XCFLAGS = 
X
X# ***************************************************************
X# Entry to bring the package up to date
X
Xall: $(PROGRAMS)
X
X# ***************************************************************
X# Standard entries to remove files from the directories
X#    tidy    -- eliminate unwanted files
X#    scratch -- delete derived files in preparation for rebuild
X
Xtidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
Xscratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
X# ***************************************************************
X# C compilations
X
Xscanner.o: scanner.c scanner.h
X	$(CC) $(CFLAGS) -c scanner.c
X
Xpiglatin.o: piglatin.c scanner.h
X	$(CC) $(CFLAGS) -c piglatin.c
X
X
Xpiglatin: piglatin.o scanner.o
X	$(CC) $(CFLAGS) -o piglatin piglatin.o scanner.o
END_OF_FILE
if test 1102 -ne `wc -c <'programs/10-Modular-Development/Makefile'`; then
    echo shar: \"'programs/10-Modular-Development/Makefile'\" unpacked with wrong size!
fi
# end of 'programs/10-Modular-Development/Makefile'
fi
if test -f 'programs/10-Modular-Development/piglatin.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/10-Modular-Development/piglatin.c'\"
else
echo shar: Extracting \"'programs/10-Modular-Development/piglatin.c'\" \(3199 characters\)
sed "s/^X//" >'programs/10-Modular-Development/piglatin.c' <<'END_OF_FILE'
X/*
X * File: piglatin.c
X * ----------------
X * This program translates a line of text from English
X * to Pig Latin.  The rules for forming Pig Latin words
X * are as follows:
X *
X * o  If the word begins with a vowel, add "way" to the
X *    end of the word.
X *
X * o  If the word begins with a consonant, extract the set
X *    of consonants up to the first vowel, move that set
X *    of consonants to the end of the word, and add "ay".
X */
X
X#include <stdio.h>
X#include <ctype.h>
X
X#include "genlib.h"
X#include "strlib.h"
X#include "simpio.h"
X#include "scanner.h"
X
X/* Private function prototypes */
X
Xstatic void TranslateLine(string line);
Xstatic bool IsLegalWord(string token);
Xstatic string TranslateWord(string word);
Xstatic int FindFirstVowel(string word);
Xstatic bool IsVowel(char ch);
X
X/* Main program */
X
Xmain()
X{
X    string line;
X
X    printf("Enter a line: ");
X    line = GetLine();
X    TranslateLine(line);
X}
X
X/*
X * Function: TranslateLine
X * Usage: TranslateLine(line);
X * ---------------------------
X * This function takes a line of text and translates
X * the words in the line to Pig Latin, displaying the
X * translation as it goes.
X */
X
Xstatic void TranslateLine(string line)
X{
X    string token;
X
X    InitScanner(line);
X    while (!AtEndOfLine()) {
X        token = GetNextToken();
X        if (IsLegalWord(token)) token = TranslateWord(token);
X        printf("%s", token);
X    }
X    printf("\n");
X}
X
X/*
X * Function: IsLegalWord
X * Usage: if (IsLegalWord(token)) ...
X * ----------------------------------
X * IsLegalWord returns TRUE if every character in the argument
X * token is alphabetic.
X */
X
Xstatic bool IsLegalWord(string token)
X{
X    int i;
X
X    for (i = 0; i < StringLength(token); i++) {
X        if (!isalpha(IthChar(token, i))) return (FALSE);
X    }
X    return (TRUE);
X}
X
X/*
X * Function: TranslateWord
X * Usage: word = TranslateWord(word)
X * ---------------------------------
X * This function translates a word from English to Pig Latin
X * and returns the translated word.
X */
X
Xstatic string TranslateWord(string word)
X{
X    int vp;
X    string head, tail;
X
X    vp = FindFirstVowel(word);
X    if (vp == -1) {
X        return (word);
X    } else if (vp == 0) {
X        return (Concat(word, "way"));
X    } else {
X        head = SubString(word, 0, vp - 1);
X        tail = SubString(word, vp, StringLength(word) - 1);
X        return (Concat(tail, Concat(head, "ay")));
X    }
X}
X
X/*
X * Function: FindFirstVowel
X * Usage: k = FindFirstVowel(word);
X * --------------------------------
X * FindFirstVowel returns the index position of the first vowel
X * in word.  If word does not contain a vowel, FindFirstVowel
X * returns -1.
X */
X
Xstatic int FindFirstVowel(string word)
X{
X    int i;
X
X    for (i = 0; i < StringLength(word); i++) {
X        if (IsVowel(IthChar(word, i))) return (i);
X    }
X    return (-1);
X}
X
X/*
X * Function: IsVowel
X * Usage: if (IsVowel(ch)) . . .
X * -----------------------------
X * IsVowel returns TRUE if ch is a vowel.  This function
X * recognizes vowels in either upper or lower case.
X */
X
Xstatic bool IsVowel(char ch)
X{
X    switch (tolower(ch)) {
X      case 'a': case 'e': case 'i': case 'o': case 'u':
X        return (TRUE);
X      default:
X        return (FALSE);
X    }
X}
END_OF_FILE
if test 3199 -ne `wc -c <'programs/10-Modular-Development/piglatin.c'`; then
    echo shar: \"'programs/10-Modular-Development/piglatin.c'\" unpacked with wrong size!
fi
# end of 'programs/10-Modular-Development/piglatin.c'
fi
if test -f 'programs/10-Modular-Development/scanner.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/10-Modular-Development/scanner.c'\"
else
echo shar: Extracting \"'programs/10-Modular-Development/scanner.c'\" \(1796 characters\)
sed "s/^X//" >'programs/10-Modular-Development/scanner.c' <<'END_OF_FILE'
X/*
X * File: scanner.c
X * ---------------
X * This file implements the scanner.h interface.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X
X#include "genlib.h"
X#include "strlib.h"
X#include "scanner.h"
X
X/*
X * Private variables
X * -----------------
X * buffer  -- Private copy of the string passed to InitScanner
X * buflen  -- Length of the buffer, saved for efficiency
X * cpos    -- Current character position in the buffer
X */
X
Xstatic string buffer;
Xstatic int buflen;
Xstatic int cpos;
X
X/*
X * Function: InitScanner
X * ---------------------
X * All this function has to do is initialize the private
X * variables used in the package.
X */
X
Xvoid InitScanner(string line)
X{
X    buffer = line;
X    buflen = StringLength(buffer);
X    cpos = 0;
X}
X
X/*
X * Function: GetNextToken
X * ----------------------
X * The implementation of GetNextToken follows its behavioral
X * description as given in the interface: if the next character
X * is alphanumeric (i.e., a letter or digit), the function
X * searches to find an unbroken string of such characters and
X * returns the entire string.  If the current character is not
X * a letter or digit, a one-character string containing that
X * character is returned.
X */
X
Xstring GetNextToken(void)
X{
X    char ch;
X    int start;
X
X    if (cpos >= buflen) Error("No more tokens");
X    ch = IthChar(buffer, cpos);
X    if (isalnum(ch)) {
X        start = cpos;
X        while (cpos < buflen && isalnum(IthChar(buffer, cpos))) {
X            cpos++;
X        }
X        return (SubString(buffer, start, cpos - 1));
X    } else {
X        cpos++;
X        return (CharToString(ch));
X    }
X}
X
X/*
X * Function: AtEndOfLine
X * ---------------------
X * This implementation compares the current buffer position
X * against the saved length.
X */
X
Xbool AtEndOfLine(void)
X{
X    return (cpos >= buflen);
X}
END_OF_FILE
if test 1796 -ne `wc -c <'programs/10-Modular-Development/scanner.c'`; then
    echo shar: \"'programs/10-Modular-Development/scanner.c'\" unpacked with wrong size!
fi
# end of 'programs/10-Modular-Development/scanner.c'
fi
if test -f 'programs/10-Modular-Development/scanner.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/10-Modular-Development/scanner.h'\"
else
echo shar: Extracting \"'programs/10-Modular-Development/scanner.h'\" \(1893 characters\)
sed "s/^X//" >'programs/10-Modular-Development/scanner.h' <<'END_OF_FILE'
X/*
X * File: scanner.h
X * ---------------
X * This file is the interface to a package that divides
X * a line into individual "tokens".  A token is defined
X * to be either
X *
X * 1. a string of consecutive letters and digits representing
X *    a word, or
X *
X * 2. a one-character string representing a separator
X *    character, such as a space or a punctuation mark.
X *
X * To use this package, you must first call
X *
X *        InitScanner(line);
X *
X * where line is the string (typically a line returned by
X * GetLine) that is to be divided into tokens.  To retrieve
X * each token in turn, you call
X *
X *        token = GetNextToken();
X *
X * When the last token has been read, the predicate function
X * AtEndOfLine returns TRUE, so that the loop structure
X *
X *        while (!AtEndOfLine()) {
X *            token = GetNextToken();
X *            . . . process the token . . .
X *        }
X *
X * serves as an idiom for processing each token on the line.
X *
X * Further details for each function are given in the
X * individual descriptions below.
X */
X
X#ifndef _scanner_h
X#define _scanner_h
X
X#include "genlib.h"
X
X/*
X * Function: InitScanner
X * Usage: InitScanner(line);
X * -------------------------
X * This function initializes the scanner and sets it up so that
X * it reads tokens from line.  After InitScanner has been called,
X * the first call to GetNextToken will return the first token
X * on the line, the next call will return the second token,
X * and so on.
X */
X
Xvoid InitScanner(string line);
X
X/*
X * Function: GetNextToken
X * Usage: word = GetNextToken();
X * -----------------------------
X * This function returns the next token on the line.
X */
X
Xstring GetNextToken(void);
X
X/*
X * Function: AtEndOfLine
X * Usage: if (AtEndOfLine()) . . .
X * -------------------------------
X * This function returns TRUE when the scanner has reached
X * the end of the line.
X */
X
Xbool AtEndOfLine(void);
X
X#endif
END_OF_FILE
if test 1893 -ne `wc -c <'programs/10-Modular-Development/scanner.h'`; then
    echo shar: \"'programs/10-Modular-Development/scanner.h'\" unpacked with wrong size!
fi
# end of 'programs/10-Modular-Development/scanner.h'
fi
if test -f 'programs/11-Arrays/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/11-Arrays/Makefile'\"
else
echo shar: Extracting \"'programs/11-Arrays/Makefile'\" \(1377 characters\)
sed "s/^X//" >'programs/11-Arrays/Makefile' <<'END_OF_FILE'
X# Makefile for cbook/11-Arrays/programs
X# Created by the ExportAll facility
X# ***************************************************************
X
XPROGRAMS = \
X    gymjudge \
X    reverse \
X    testrev \
X    countlet 
X
X# ***************************************************************
X# Parameters to control Makefile operation
X# Note that the gccx command script must be defined
X
XCC = gccx
XCFLAGS = 
X
X# ***************************************************************
X# Entry to bring the package up to date
X
Xall: $(PROGRAMS)
X
X# ***************************************************************
X# Standard entries to remove files from the directories
X#    tidy    -- eliminate unwanted files
X#    scratch -- delete derived files in preparation for rebuild
X
Xtidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
Xscratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
X# ***************************************************************
X# C compilations
X
Xgymjudge.o: gymjudge.c
X	$(CC) $(CFLAGS) -c gymjudge.c
X
Xreverse.o: reverse.c
X	$(CC) $(CFLAGS) -c reverse.c
X
Xtestrev.o: testrev.c
X	$(CC) $(CFLAGS) -c testrev.c
X
Xcountlet.o: countlet.c
X	$(CC) $(CFLAGS) -c countlet.c
X
X
Xgymjudge: gymjudge.o
X	$(CC) $(CFLAGS) -o gymjudge gymjudge.o
X
Xreverse: reverse.o
X	$(CC) $(CFLAGS) -o reverse reverse.o
X
Xtestrev: testrev.o
X	$(CC) $(CFLAGS) -o testrev testrev.o
X
Xcountlet: countlet.o
X	$(CC) $(CFLAGS) -o countlet countlet.o
END_OF_FILE
if test 1377 -ne `wc -c <'programs/11-Arrays/Makefile'`; then
    echo shar: \"'programs/11-Arrays/Makefile'\" unpacked with wrong size!
fi
# end of 'programs/11-Arrays/Makefile'
fi
if test -f 'programs/11-Arrays/countlet.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/11-Arrays/countlet.c'\"
else
echo shar: Extracting \"'programs/11-Arrays/countlet.c'\" \(3867 characters\)
sed "s/^X//" >'programs/11-Arrays/countlet.c' <<'END_OF_FILE'
X/*
X * File: countlet.c
X * ----------------
X * This program counts the occurrences of individual letters
X * that appear in text read in from the user.  This program
X * might be useful as a tool in solving cryptograms.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include "simpio.h"
X#include "strlib.h"
X#include "genlib.h"
X
X/*
X * Constants
X * ---------
X * MaxLines -- Maximum number of input lines
X * NLetters -- Number of letters
X */
X
X#define MaxLines 100
X#define NLetters  26
X
X/* Private function declarations */
X
Xstatic void CountLetters(int letterCounts[]);
Xstatic void CountLettersInString(string str, int letterCounts[]);
Xstatic void RecordLetter(char ch, int letterCounts[]);
Xstatic void DisplayLetterCounts(const int letterCounts[]);
Xstatic int LetterIndex(char ch);
Xvoid ClearIntegerArray(int array[], int n);
X
X/* Main program */
X
Xmain()
X{
X    int letterCounts[NLetters];
X
X    printf("This program counts letter frequencies.\n");
X    printf("Enter a blank line to signal end of input.\n");
X    ClearIntegerArray(letterCounts, NLetters);
X    CountLetters(letterCounts);
X    DisplayLetterCounts(letterCounts);
X}
X
X/*
X * Function: CountLetters
X * Usage: CountLetters(letterCounts);
X * ----------------------------------
X * This function updates the values in the letterCounts array
X * by scanning through a series of strings read in from the
X * user.  A blank line is used to signal the end of the input
X * text.
X */
X
Xstatic void CountLetters(int letterCounts[])
X{
X    string line;
X
X    while (TRUE) {
X        line = GetLine();
X        if (StringLength(line) == 0) break;
X        CountLettersInString(line, letterCounts);
X    }
X}
X
X/*
X * Function: CountLettersInString
X * Usage: CountLettersInString(str, letterCounts);
X * -----------------------------------------------
X * This function updates the values in the letterCounts array for
X * each character in the string str.
X */
X
Xstatic void CountLettersInString(string str, int letterCounts[])
X{
X    int i;
X
X    for (i = 0; i < StringLength(str); i++) {
X        RecordLetter(IthChar(str, i), letterCounts);
X    }
X}
X
X/*
X * Function: RecordLetter
X * Usage: RecordLetter(ch, letterCounts);
X * --------------------------------------
X * This function records the fact that the character ch has
X * been seen by incrementing the appropriate element in the
X * letterCounts array.  Non-letters are ignored.
X */
X
Xvoid RecordLetter(char ch, int letterCounts[])
X{
X    int index;
X
X    index = LetterIndex(ch);
X    if (index != -1) letterCounts[index]++;
X}
X
X/*
X * Function: DisplayLetterCounts
X * Usage: DisplayLetterCounts(letterCounts);
X * -----------------------------------------
X * This function displays the letter frequency table, leaving
X * out any letters that did not occur.
X */
X
Xvoid DisplayLetterCounts(const int letterCounts[])
X{
X    char ch;
X    int num;
X
X    for (ch = 'A'; ch <= 'Z'; ch++) {
X        num = letterCounts[LetterIndex(ch)];
X        if (num != 0) printf("%c  %4d\n", ch, num);
X    }
X}
X
X/*
X * Function: LetterIndex
X * Usage: index = LetterIndex(ch);
X * -------------------------------
X * This function converts a character into the appropriate index
X * for use with the letterCounts array.  In this implementation,
X * LetterIndex converts characters in either case to an integer
X * in the range 0 to 25.  If ch is not a valid letter, LetterIndex
X * returns -1.  Clients should check for a -1 return value unless
X * they are able to guarantee that the argument is a letter.
X */
X
Xint LetterIndex(char ch)
X{
X    if (isalpha(ch)) {
X        return (toupper(ch) - 'A');
X    } else {
X        return (-1);
X    }
X}
X
X/*
X * Function: ClearIntegerArray
X * Usage: ClearIntegerArray(array, n);
X * -----------------------------------
X * This function sets the first n elements in the array to 0.
X */
X
Xvoid ClearIntegerArray(int array[], int n)
X{
X    int i;
X
X    for (i = 0; i < n; i++) {
X        array[i] = 0;
X    }
X}
END_OF_FILE
if test 3867 -ne `wc -c <'programs/11-Arrays/countlet.c'`; then
    echo shar: \"'programs/11-Arrays/countlet.c'\" unpacked with wrong size!
fi
# end of 'programs/11-Arrays/countlet.c'
fi
if test -f 'programs/11-Arrays/gymjudge.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/11-Arrays/gymjudge.c'\"
else
echo shar: Extracting \"'programs/11-Arrays/gymjudge.c'\" \(714 characters\)
sed "s/^X//" >'programs/11-Arrays/gymjudge.c' <<'END_OF_FILE'
X/*
X * File: gymjudge.c
X * ----------------
X * This program averages a set of five gymnastic scores.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
X/*
X * Constants
X * ---------
X * NJudges -- Number of judges
X */
X
X#define NJudges 5
X
X/* Main program */
X
Xmain()
X{
X    double gymnasticScores[NJudges];
X    double total, average;
X    int i;
X
X    printf("Please enter a score for each judge.\n");
X    for (i = 0; i < NJudges; i++) {
X        printf("Score for judge #%d:  ", i);
X        gymnasticScores[i] = GetReal();
X    }
X    total = 0;
X    for (i = 0; i < NJudges; i++) {
X        total += gymnasticScores[i];
X    }
X    average = total / NJudges;
X    printf("The average score is %.2f\n", average);
X}
END_OF_FILE
if test 714 -ne `wc -c <'programs/11-Arrays/gymjudge.c'`; then
    echo shar: \"'programs/11-Arrays/gymjudge.c'\" unpacked with wrong size!
fi
# end of 'programs/11-Arrays/gymjudge.c'
fi
if test -f 'programs/11-Arrays/reverse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/11-Arrays/reverse.c'\"
else
echo shar: Extracting \"'programs/11-Arrays/reverse.c'\" \(3592 characters\)
sed "s/^X//" >'programs/11-Arrays/reverse.c' <<'END_OF_FILE'
X/*
X * File: reverse.c
X * ---------------
X * This program reads in an array of integers, reverses the
X * elements of the array, and then display the elements in
X * their reversed order.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
X/*
X * Constants
X * ---------
X * MaxElements -- Maximum number of elements
X * Sentinel    -- Value used to terminate input
X */
X
X#define MaxElements 250
X#define Sentinel      0
X
X/* Private function prototypes */
X
Xstatic int GetIntegerArray(int array[], int max, int sentinel);
Xstatic void PrintIntegerArray(int array[], int n);
Xstatic void ReverseIntegerArray(int array[], int n);
Xstatic void SwapIntegerElements(int array[], int p1, int p2);
Xstatic void GiveInstructions(void);
X
X/* Main program */
X
Xmain()
X{
X    int list[MaxElements], n;
X
X    GiveInstructions();
X    n = GetIntegerArray(list, MaxElements, Sentinel);
X    ReverseIntegerArray(list, n);
X    PrintIntegerArray(list, n);
X}
X
X/*
X * Function: GetIntegerArray
X * Usage: n = GetIntegerArray(array, max, sentinel);
X * -------------------------------------------------
X * This function reads elements into an integer array by
X * reading values, one per line, from the keyboard.  The end
X * of the input data is indicated by the parameter sentinel.
X * The caller is responsible for declaring the array and
X * passing it as a parameter, along with its allocated
X * size.  The value returned is the number of elements
X * actually entered and therefore gives the effective size
X * of the array, which is typically less than the allocated
X * size given by max.  If the user types in more than max
X * elements, GetIntegerArray generates an error.
X */
X
Xstatic int GetIntegerArray(int array[], int max, int sentinel)
X{
X    int n, value;
X
X    n = 0;
X    while (TRUE) {
X        printf(" ? ");
X        value = GetInteger();
X        if (value == sentinel) break;
X        if (n == max) Error("Too many input items for array");
X        array[n] = value;
X        n++;
X    }
X    return (n);
X}
X
X/*
X * Function: PrintIntegerArray
X * Usage: PrintIntegerArray(array, n);
X * -----------------------------------
X * This function displays the first n values in array,
X * one per line, on the console.
X */
X
Xstatic void PrintIntegerArray(int array[], int n)
X{
X    int i;
X
X    for (i = 0; i < n; i++) {
X        printf("%d\n", array[i]);
X    }
X}
X
X/*
X * Function: ReverseIntegerArray
X * Usage: ReverseIntegerArray(array, n);
X * -------------------------------------
X * This function reverses the elements of array, which has n as
X * its effective size.  The procedure operates by going through
X * the first half of the array and swapping each element with
X * its counterpart at the end of the array.
X */
X
Xstatic void ReverseIntegerArray(int array[], int n)
X{
X    int i;
X
X    for (i = 0; i < n / 2; i++) {
X        SwapIntegerElements(array, i, n - i - 1);
X    }
X}
X
X/*
X * Function: SwapIntegerElements
X * Usage: SwapIntegerElements(array, p1, p2);
X * ------------------------------------------
X * This function swaps the elements in array at index
X * positions p1 and p2.
X */
X
Xstatic void SwapIntegerElements(int array[], int p1, int p2)
X{
X    int tmp;
X
X    tmp = array[p1];
X    array[p1] = array[p2];
X    array[p2] = tmp;
X}
X
X/*
X * Function: GiveInstructions
X * Usage: GiveInstructions();
X * --------------------------
X * This function gives instructions for the array reversal program.
X */
X
Xstatic void GiveInstructions(void)
X{
X    printf("Enter numbers, one per line, ending with the\n");
X    printf("sentinel value %d.  The program will then\n", Sentinel);
X    printf("display those values in reverse order.\n");
X}
END_OF_FILE
if test 3592 -ne `wc -c <'programs/11-Arrays/reverse.c'`; then
    echo shar: \"'programs/11-Arrays/reverse.c'\" unpacked with wrong size!
fi
# end of 'programs/11-Arrays/reverse.c'
fi
if test -f 'programs/11-Arrays/testrev.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/11-Arrays/testrev.c'\"
else
echo shar: Extracting \"'programs/11-Arrays/testrev.c'\" \(2185 characters\)
sed "s/^X//" >'programs/11-Arrays/testrev.c' <<'END_OF_FILE'
X/*
X * File: testrev.c
X * ---------------
X * This program simply reads in an array of integers  and then
X * display them elements in the original order.  It is a test
X * program on the way to writing the reverse program.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
X/*
X * Constants
X * ---------
X * MaxElements -- Maximum number of elements
X * Sentinel    -- Value used to terminate input
X */
X
X#define MaxElements 250
X#define Sentinel      0
X
X/* Private function prototypes */
X
Xstatic int GetIntegerArray(int array[], int max, int sentinel);
Xstatic void PrintIntegerArray(int array[], int n);
Xstatic void GiveInstructions(void);
X
X/* Main program */
X
Xmain()
X{
X    int list[MaxElements], n;
X
X    n = GetIntegerArray(list, MaxElements, Sentinel);
X    PrintIntegerArray(list, n);
X}
X
X/*
X * Function: GetIntegerArray
X * Usage: n = GetIntegerArray(array, max, sentinel);
X * -------------------------------------------------
X * This function reads elements into an integer array by
X * reading values, one per line, from the keyboard.  The end
X * of the input data is indicated by the parameter sentinel.
X * The caller is responsible for declaring the array and
X * passing it as a parameter, along with its allocated
X * size.  The value returned is the number of elements
X * actually entered and therefore gives the effective size
X * of the array, which is typically less than the allocated
X * size given by max.  If the user types in more than max
X * elements, GetIntegerArray generates an error.
X */
X
Xstatic int GetIntegerArray(int array[], int max, int sentinel)
X{
X    int n, value;
X
X    n = 0;
X    while (TRUE) {
X        printf(" ? ");
X        value = GetInteger();
X        if (value == sentinel) break;
X        if (n == max) Error("Too many input items for array");
X        array[n] = value;
X        n++;
X    }
X    return (n);
X}
X
X/*
X * Function: PrintIntegerArray
X * Usage: PrintIntegerArray(array, n);
X * -----------------------------------
X * This function displays the first n values in array,
X * one per line, on the console.
X */
X
Xstatic void PrintIntegerArray(int array[], int n)
X{
X    int i;
X
X    for (i = 0; i < n; i++) {
X        printf("%d\n", array[i]);
X    }
X}
END_OF_FILE
if test 2185 -ne `wc -c <'programs/11-Arrays/testrev.c'`; then
    echo shar: \"'programs/11-Arrays/testrev.c'\" unpacked with wrong size!
fi
# end of 'programs/11-Arrays/testrev.c'
fi
if test -f 'programs/12-Sorting/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/12-Sorting/Makefile'\"
else
echo shar: Extracting \"'programs/12-Sorting/Makefile'\" \(1457 characters\)
sed "s/^X//" >'programs/12-Sorting/Makefile' <<'END_OF_FILE'
X# Makefile for cbook/12-Sorting/programs
X# Created by the ExportAll facility
X# ***************************************************************
X
XPROGRAMS = \
X    testsort \
X    findcoin \
X    mileage \
X    mileage2 
X
X# ***************************************************************
X# Parameters to control Makefile operation
X# Note that the gccx command script must be defined
X
XCC = gccx
XCFLAGS = 
X
X# ***************************************************************
X# Entry to bring the package up to date
X
Xall: $(PROGRAMS)
X
X# ***************************************************************
X# Standard entries to remove files from the directories
X#    tidy    -- eliminate unwanted files
X#    scratch -- delete derived files in preparation for rebuild
X
Xtidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
Xscratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
X# ***************************************************************
X# C compilations
X
Xfindcoin.o: findcoin.c
X	$(CC) $(CFLAGS) -c findcoin.c
X
Xmileage.o: mileage.c
X	$(CC) $(CFLAGS) -c mileage.c
X
Xmileage2.o: mileage2.c
X	$(CC) $(CFLAGS) -c mileage2.c
X
Xsort.o: sort.c sort.h
X	$(CC) $(CFLAGS) -c sort.c
X
Xtestsort.o: testsort.c sort.h
X	$(CC) $(CFLAGS) -c testsort.c
X
X
Xtestsort: testsort.o sort.o
X	$(CC) $(CFLAGS) -o testsort testsort.o sort.o
X
Xfindcoin: findcoin.o
X	$(CC) $(CFLAGS) -o findcoin findcoin.o
X
Xmileage: mileage.o
X	$(CC) $(CFLAGS) -o mileage mileage.o
X
Xmileage2: mileage2.o
X	$(CC) $(CFLAGS) -o mileage2 mileage2.o
END_OF_FILE
if test 1457 -ne `wc -c <'programs/12-Sorting/Makefile'`; then
    echo shar: \"'programs/12-Sorting/Makefile'\" unpacked with wrong size!
fi
# end of 'programs/12-Sorting/Makefile'
fi
if test -f 'programs/12-Sorting/findcoin.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/12-Sorting/findcoin.c'\"
else
echo shar: Extracting \"'programs/12-Sorting/findcoin.c'\" \(1651 characters\)
sed "s/^X//" >'programs/12-Sorting/findcoin.c' <<'END_OF_FILE'
X/*
X * File: findcoin.c
X * ----------------
X * This program uses a search operation to report the names of
X * legal U.S. coins.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include "simpio.h"
X#include "genlib.h"
X
X/*
X * Global variables
X * ----------------
X * coinNames  -- Array containing the name of each coin
X * coinValues -- Array containing the corresponding coin values
X * nCoins     -- Number of distinct coins
X */
X
Xstatic string coinNames[] = {
X    "penny",
X    "nickel",
X    "dime",
X    "quarter",
X    "half-dollar",
X};
X
Xstatic int coinValues[] = { 1, 5, 10, 25, 50 };
X
Xstatic int nCoins = sizeof coinValues / sizeof coinValues[0];
X
X/* Private function declarations */
X
Xstatic int FindIntegerInArray(int key, int array[], int n);
X
X/* Main program */
X
Xmain()
X{
X    int value, index;
X
X    printf("This program looks up names of U.S. coins.\n");
X    printf("Enter coin value: ");
X    value = GetInteger();
X    index = FindIntegerInArray(value, coinValues, nCoins);
X    if (index == -1) {
X        printf("There is no such coin.\n");
X    } else {
X        printf("That's called a %s.\n", coinNames[index]);
X    }
X}
X
X/*
X * Function: FindIntegerInArray
X * Usage: index = FindIntegerInArray(key, array, n);
X * -----------------------------------------------
X * This function returns the index of the first element in the
X * specified array of integers that matches the value key.  If
X * key does not appear in the first n elements of the array,
X * FindIntegerInArray returns -1.
X */
X
Xstatic int FindIntegerInArray(int key, int array[], int n)
X{
X    int i;
X
X    for (i = 0; i < n; i++) {
X        if (key == array[i]) return (i);
X    }
X    return (-1);
X}
END_OF_FILE
if test 1651 -ne `wc -c <'programs/12-Sorting/findcoin.c'`; then
    echo shar: \"'programs/12-Sorting/findcoin.c'\" unpacked with wrong size!
fi
# end of 'programs/12-Sorting/findcoin.c'
fi
if test -f 'programs/12-Sorting/mileage.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/12-Sorting/mileage.c'\"
else
echo shar: Extracting \"'programs/12-Sorting/mileage.c'\" \(3461 characters\)
sed "s/^X//" >'programs/12-Sorting/mileage.c' <<'END_OF_FILE'
X/*
X * File: mileage.c
X * ---------------
X * This program simulates the operation of a mileage table.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include "simpio.h"
X#include "strlib.h"
X#include "genlib.h"
X
X/*
X * Constants
X * ---------
X * NCities -- Number of cities
X */
X
X#define NCities 12
X
X/*
X * Global variable: mileageTable
X * -----------------------------
X * This table is a two-dimensional array that holds the distance
X * between the cities whose indices are the row and column numbers.
X * Data source: Rand McNally Road Atlas.
X */
X
Xstatic int mileageTable[NCities][NCities] = {
X    {   0,1108, 708,1430, 732, 791,2191, 663, 854, 748,2483,2625},
X    {1108,   0, 994,1998, 799,1830,3017,1520, 222, 315,3128,3016},
X    { 708, 994,   0,1021, 279,1091,2048,1397, 809, 785,2173,2052},
X    {1430,1998,1021,   0,1283,1034,1031,2107,1794,1739,1255,1341},
X    { 732, 799, 279,1283,   0,1276,2288,1385, 649, 609,2399,2327},
X    { 791,1830,1091,1034,1276,   0,1541,1190,1610,1511,1911,2369},
X    {2191,3017,2048,1031,2288,1541,   0,2716,2794,2703, 387,1134},
X    { 663,1520,1397,2107,1385,1190,2716,   0,1334,1230,3093,3303},
X    { 854, 222, 809,1794, 649,1610,2794,1334,   0, 101,2930,2841},
X    { 748, 315, 785,1739, 609,1511,2703,1230, 101,   0,2902,2816},
X    {2483,3128,2173,1255,2399,1911, 387,3093,2930,2902,   0, 810},
X    {2625,3016,2052,1341,2327,2369,1134,3303,2841,2816, 810,   0},
X};
X
X/*
X * Global variable: cityTable
X * --------------------------
X * The array cityTable holds the names of the cities used in the
X * mileage table.
X */
X
Xstatic string cityTable[NCities] = {
X    "Atlanta",
X    "Boston",
X    "Chicago",
X    "Denver",
X    "Detroit",
X    "Houston",
X    "Los Angeles",
X    "Miami",
X    "New York",
X    "Philadelphia",
X    "San Francisco",
X    "Seattle",
X};
X
X/* Private function declarations */
X
Xstatic int GetCity(string prompt);
Xstatic int FindStringInArray(string key, string array[], int n);
X
X/* Main program */
X
Xmain()
X{
X    int city1, city2;
X
X    printf("This program looks up intercity mileage.\n");
X    city1 = GetCity("Enter name of city #1: ");
X    city2 = GetCity("Enter name of city #2: ");
X    printf("Distance between %s", cityTable[city1]);
X    printf(" and %s:", cityTable[city2]);
X    printf(" %d miles.\n", mileageTable[city1][city2]);
X}
X
X/*
X * Function: GetCity
X * Usage: n = GetCity(prompt);
X * ---------------------------
X * This function prompts the user for a city name, reads in a
X * string, and returns the index corresponding to that city,
X * if it exists.  If an undefined city name is entered, the
X * user is given a chance to retry.
X */
X
Xstatic int GetCity(string prompt)
X{
X    string cityName;
X    int index;
X
X    while (TRUE) {
X        printf("%s", prompt);
X        cityName = GetLine();
X        index = FindStringInArray(cityName, cityTable, NCities);
X        if (index >= 0) break;
X        printf("Unknown city name -- try again.\n");
X    }
X    return (index);
X}
X
X/*
X * Function: FindStringInArray
X * Usage: index = FindStringInArray(key, array, n);
X * ------------------------------------------------
X * This function returns the index of the first element in the
X * specified array of strings that matches the value key.  If
X * key does not appear in the first n elements of the array,
X * FindStringInArray returns -1.
X */
X
Xstatic int FindStringInArray(string key, string array[], int n)
X{
X    int i;
X
X    for (i = 0; i < n; i++) {
X        if (StringEqual(key, array[i])) return (i);
X    }
X    return (-1);
X}
END_OF_FILE
if test 3461 -ne `wc -c <'programs/12-Sorting/mileage.c'`; then
    echo shar: \"'programs/12-Sorting/mileage.c'\" unpacked with wrong size!
fi
# end of 'programs/12-Sorting/mileage.c'
fi
if test -f 'programs/12-Sorting/mileage2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/12-Sorting/mileage2.c'\"
else
echo shar: Extracting \"'programs/12-Sorting/mileage2.c'\" \(4498 characters\)
sed "s/^X//" >'programs/12-Sorting/mileage2.c' <<'END_OF_FILE'
X/*
X * File: mileage2.c
X * ----------------
X * This program simulates the operation of a mileage table.  This
X * implementation uses the binary search algorithm to look up the
X * city name.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include "simpio.h"
X#include "strlib.h"
X#include "genlib.h"
X
X/*
X * Constants
X * ---------
X * NCities -- Number of cities
X */
X
X#define NCities 12
X
X/*
X * Global variable: mileageTable
X * -----------------------------
X * This table is a two-dimensional array that holds the distance
X * between the cities whose indices are the row and column numbers.
X * Data source: Rand McNally Road Atlas.
X */
X
Xstatic int mileageTable[NCities][NCities] = {
X    {   0,1108, 708,1430, 732, 791,2191, 663, 854, 748,2483,2625},
X    {1108,   0, 994,1998, 799,1830,3017,1520, 222, 315,3128,3016},
X    { 708, 994,   0,1021, 279,1091,2048,1397, 809, 785,2173,2052},
X    {1430,1998,1021,   0,1283,1034,1031,2107,1794,1739,1255,1341},
X    { 732, 799, 279,1283,   0,1276,2288,1385, 649, 609,2399,2327},
X    { 791,1830,1091,1034,1276,   0,1541,1190,1610,1511,1911,2369},
X    {2191,3017,2048,1031,2288,1541,   0,2716,2794,2703, 387,1134},
X    { 663,1520,1397,2107,1385,1190,2716,   0,1334,1230,3093,3303},
X    { 854, 222, 809,1794, 649,1610,2794,1334,   0, 101,2930,2841},
X    { 748, 315, 785,1739, 609,1511,2703,1230, 101,   0,2902,2816},
X    {2483,3128,2173,1255,2399,1911, 387,3093,2930,2902,   0, 810},
X    {2625,3016,2052,1341,2327,2369,1134,3303,2841,2816, 810,   0},
X};
X
X/*
X * Global variable: cityTable
X * --------------------------
X * The array cityTable holds the names of the cities used in the
X * mileage table.
X */
X
Xstatic string cityTable[NCities] = {
X    "Atlanta",
X    "Boston",
X    "Chicago",
X    "Denver",
X    "Detroit",
X    "Houston",
X    "Los Angeles",
X    "Miami",
X    "New York",
X    "Philadelphia",
X    "San Francisco",
X    "Seattle",
X};
X
X/* Private function declarations */
X
Xstatic int GetCity(string prompt);
Xstatic int FindStringInSortedArray(string key,
X                            string array[],
X                            int n);
X
X/* Main program */
X
Xmain()
X{
X    int city1, city2;
X
X    printf("This program looks up intercity mileage.\n");
X    city1 = GetCity("Enter name of city #1: ");
X    city2 = GetCity("Enter name of city #2: ");
X    printf("Distance between %s", cityTable[city1]);
X    printf(" and %s:", cityTable[city2]);
X    printf(" %d miles.\n", mileageTable[city1][city2]);
X}
X
X/*
X * Function: GetCity
X * Usage: n = GetCity(prompt);
X * ---------------------------
X * This function prompts the user for a city name, reads in a
X * string, and returns the index corresponding to that city,
X * if it exists.  If an undefined city name is entered, the
X * user is given a chance to retry.
X */
X
Xstatic int GetCity(string prompt)
X{
X    string cityName;
X    int index;
X
X    while (TRUE) {
X        printf("%s", prompt);
X        cityName = GetLine();
X        index = FindStringInSortedArray(cityName, cityTable, NCities);
X        if (index >= 0) break;
X        printf("Unknown city name -- try again.\n");
X    }
X    return (index);
X}
X
X/*
X * Function: FindStringInSortedArray
X * Usage: index = FindStringInSortedArray(key, array, n);
X * ------------------------------------------------------
X * This function returns the index of an element that matches key
X * in the specified array of strings, which must be sorted in
X * lexicographic order.  If key appears more than once in the
X * array, the function can return any index at which it appears.
X * If key does not appear at all in the first n elements
X * of the array, FindStringInSortedArray returns -1.
X *
X * This implementation uses the "binary search" algorithm.  At
X * each stage, the function computes the midpoint of the remaining
X * range and compares the element at that index position to the
X * key.  If there is a match, the function returns the index.
X * If the key is less than the string at that index position, the
X * function searches in the first half of the array; if the key is
X * larger, the function searches in the second half of the array.
X */
X
Xstatic int FindStringInSortedArray(string key,
X                            string array[],
X                            int n)
X{
X    int lh, rh, mid, cmp;
X
X    lh = 0;
X    rh = n - 1;
X    while (lh <= rh) {
X        mid = (lh + rh) / 2;
X        cmp = StringCompare(key, array[mid]);
X        if (cmp == 0) return (mid);
X        if (cmp < 0) {
X            rh = mid - 1;
X        } else {
X            lh = mid + 1;
X        }
X    }
X    return (-1);
X}
END_OF_FILE
if test 4498 -ne `wc -c <'programs/12-Sorting/mileage2.c'`; then
    echo shar: \"'programs/12-Sorting/mileage2.c'\" unpacked with wrong size!
fi
# end of 'programs/12-Sorting/mileage2.c'
fi
if test -f 'programs/12-Sorting/sort.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/12-Sorting/sort.c'\"
else
echo shar: Extracting \"'programs/12-Sorting/sort.c'\" \(2189 characters\)
sed "s/^X//" >'programs/12-Sorting/sort.c' <<'END_OF_FILE'
X/*
X * File: sort.c
X * ------------
X * This file implements the sort.h interface using the selection
X * sort algorithm.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "sort.h"
X
X/* Private function prototypes */
X
Xstatic int FindSmallestInteger(int array[], int low, int high);
Xstatic void SwapIntegerElements(int array[], int p1, int p2);
X
X/*
X * Function: SortIntegerArray
X * --------------------------
X * This implementation uses an algorithm called selection sort,
X * which can be described in English as follows.  With your left
X * hand, point at each element in the array in turn, starting at
X * index 0.  At each step in the cycle:
X *
X * (1)  Find the smallest element in the range between your left
X *      hand and the end of the array, and point at that element
X *      with your right hand.
X *
X * (2)  Move that element into its correct index position by
X *      switching the elements indicated by your left and right
X *      hands.
X */
X
Xvoid SortIntegerArray(int array[], int n)
X{
X    int lh, rh;
X
X    for (lh = 0; lh < n; lh++) {
X        rh = FindSmallestInteger(array, lh, n-1);
X        SwapIntegerElements(array, lh, rh);
X    }
X}
X
X/*
X * Function: FindSmallestInteger
X * Usage: index = FindSmallestInteger(array, low, high);
X * -----------------------------------------------------
X * This function returns the index of the smallest value in the
X * specified array of integers, searching only between the index
X * positions low and high, inclusive.  It operates by keeping track
X * of the index of the smallest so far in the variable spos.  If the
X * index range is empty, the function returns low.
X */
X
Xstatic int FindSmallestInteger(int array[], int low, int high)
X{
X    int i, spos;
X
X    spos = low;
X    for (i = low; i <= high; i++) {
X        if (array[i] < array[spos]) spos = i;
X    }
X    return (spos);
X}
X
X/*
X * Function: SwapIntegerElements
X * Usage: SwapIntegerElements(array, p1, p2);
X * ------------------------------------------
X * This function swaps the elements in array at index
X * positions p1 and p2.
X */
X
Xstatic void SwapIntegerElements(int array[], int p1, int p2)
X{
X    int tmp;
X
X    tmp = array[p1];
X    array[p1] = array[p2];
X    array[p2] = tmp;
X}
END_OF_FILE
if test 2189 -ne `wc -c <'programs/12-Sorting/sort.c'`; then
    echo shar: \"'programs/12-Sorting/sort.c'\" unpacked with wrong size!
fi
# end of 'programs/12-Sorting/sort.c'
fi
if test -f 'programs/12-Sorting/sort.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/12-Sorting/sort.h'\"
else
echo shar: Extracting \"'programs/12-Sorting/sort.h'\" \(656 characters\)
sed "s/^X//" >'programs/12-Sorting/sort.h' <<'END_OF_FILE'
X/*
X * File: sort.h
X * ------------
X * This file provides an interface to a simple procedure
X * for sorting an integer array into increasing order.
X */
X
X#ifndef _sort_h
X#define _sort_h
X
X/*
X * Function: SortIntegerArray
X * Usage: SortIntegerArray(array, n);
X * ----------------------------------
X * This function sorts the first n elements in array into
X * increasing numerical order.  In order to use this procedure,
X * you must declare the array in the calling program and pass
X * the effective number of elements as the parameter n.
X * In most cases, the array will have a larger allocated
X * size.
X */
X
Xvoid SortIntegerArray(int array[], int n);
X
X#endif
END_OF_FILE
if test 656 -ne `wc -c <'programs/12-Sorting/sort.h'`; then
    echo shar: \"'programs/12-Sorting/sort.h'\" unpacked with wrong size!
fi
# end of 'programs/12-Sorting/sort.h'
fi
if test -f 'programs/12-Sorting/testsort.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/12-Sorting/testsort.c'\"
else
echo shar: Extracting \"'programs/12-Sorting/testsort.c'\" \(2402 characters\)
sed "s/^X//" >'programs/12-Sorting/testsort.c' <<'END_OF_FILE'
X/*
X * File: testsort.c
X * ----------------
X * This program tests the sort.c implementation.  In this example
X * the array is considered to be a list of exam scores.  The
X * test program reads in a list of scores, sorts them, and then
X * displays the sorted list.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X#include "sort.h"
X
X/*
X * Constants
X * ---------
X * MaxScores -- Maximum number of scores
X * Sentinel  -- Value used to terminate input
X */
X
X#define MaxScores 100
X#define Sentinel   -1
X
X/* Private function prototypes */
X
Xstatic int GetIntegerArray(int array[], int max, int sentinel);
Xstatic void PrintIntegerArray(int array[], int n);
X
X/* Main program */
X
Xmain()
X{
X    int scores[MaxScores];
X    int n;
X
X    printf("Enter exam scores, one per line, ending\n");
X    printf("with the sentinel value %d.\n", Sentinel);
X    n = GetIntegerArray(scores, MaxScores, Sentinel);
X    SortIntegerArray(scores, n);
X    printf("\nThe sorted exam scores are:\n");
X    PrintIntegerArray(scores, n);
X}
X
X/*
X * Function: GetIntegerArray
X * Usage: n = GetIntegerArray(array, max, sentinel);
X * -------------------------------------------------
X * This function reads elements into an integer array by
X * reading values, one per line, from the keyboard.  The end
X * of the input data is indicated by the parameter sentinel.
X * The caller is responsible for declaring the array and
X * passing it as a parameter, along with its allocated
X * size.  The value returned is the number of elements
X * actually entered and therefore gives the effective size
X * of the array, which is typically less than the allocated
X * size given by max.  If the user types in more than max
X * elements, GetIntegerArray generates an error.
X */
X
Xstatic int GetIntegerArray(int array[], int max, int sentinel)
X{
X    int n, value;
X
X    n = 0;
X    while (TRUE) {
X        printf(" ? ");
X        value = GetInteger();
X        if (value == sentinel) break;
X        if (n == max) Error("Too many input items for array");
X        array[n] = value;
X        n++;
X    }
X    return (n);
X}
X
X/*
X * Function: PrintIntegerArray
X * Usage: PrintIntegerArray(array, n);
X * -----------------------------------
X * This function displays the first n values in array,
X * one per line, on the console.
X */
X
Xstatic void PrintIntegerArray(int array[], int n)
X{
X    int i;
X
X    for (i = 0; i < n; i++) {
X        printf("%d\n", array[i]);
X    }
X}
END_OF_FILE
if test 2402 -ne `wc -c <'programs/12-Sorting/testsort.c'`; then
    echo shar: \"'programs/12-Sorting/testsort.c'\" unpacked with wrong size!
fi
# end of 'programs/12-Sorting/testsort.c'
fi
if test -f 'programs/13-Pointers/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/13-Pointers/Makefile'\"
else
echo shar: Extracting \"'programs/13-Pointers/Makefile'\" \(1178 characters\)
sed "s/^X//" >'programs/13-Pointers/Makefile' <<'END_OF_FILE'
X# Makefile for cbook/13-Pointers/programs
X# Created by the ExportAll facility
X# ***************************************************************
X
XPROGRAMS = \
X    testsort \
X    hours 
X
X# ***************************************************************
X# Parameters to control Makefile operation
X# Note that the gccx command script must be defined
X
XCC = gccx
XCFLAGS = 
X
X# ***************************************************************
X# Entry to bring the package up to date
X
Xall: $(PROGRAMS)
X
X# ***************************************************************
X# Standard entries to remove files from the directories
X#    tidy    -- eliminate unwanted files
X#    scratch -- delete derived files in preparation for rebuild
X
Xtidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
Xscratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
X# ***************************************************************
X# C compilations
X
Xhours.o: hours.c
X	$(CC) $(CFLAGS) -c hours.c
X
Xsort.o: sort.c sort.h
X	$(CC) $(CFLAGS) -c sort.c
X
Xtestsort.o: testsort.c sort.h
X	$(CC) $(CFLAGS) -c testsort.c
X
X
Xtestsort: testsort.o sort.o
X	$(CC) $(CFLAGS) -o testsort testsort.o sort.o
X
Xhours: hours.o
X	$(CC) $(CFLAGS) -o hours hours.o
END_OF_FILE
if test 1178 -ne `wc -c <'programs/13-Pointers/Makefile'`; then
    echo shar: \"'programs/13-Pointers/Makefile'\" unpacked with wrong size!
fi
# end of 'programs/13-Pointers/Makefile'
fi
if test -f 'programs/13-Pointers/hours.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/13-Pointers/hours.c'\"
else
echo shar: Extracting \"'programs/13-Pointers/hours.c'\" \(1280 characters\)
sed "s/^X//" >'programs/13-Pointers/hours.c' <<'END_OF_FILE'
X/*
X * File: hours.c
X * -------------
X * This program converts a time given in minutes into
X * separate values representing hours and minutes.  The
X * program is written as an illustration of C's mechanism
X * for simulating call by reference.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
X/* Constants */
X
X#define MinutesPerHour 60
X
X/* Function prototypes */
X
Xstatic void ConvertTimeToHM(int time, int *pHours, int *pMinutes);
X
X/* Test program */
X
Xmain()
X{
X    int time, hours, minutes;
X
X    printf("Test program to convert time values\n");
X    printf("Enter a time duration in minutes: ");
X    time = GetInteger();
X    ConvertTimeToHM(time, &hours, &minutes);
X    printf("HH:MM format: %d:%02d\n", hours, minutes);
X}
X
X/*
X * Function: ConvertTimeToHM
X * Usage: ConvertTimeToHM(time, &hours, &minutes);
X * -----------------------------------------------
X * This function converts a time value given in minutes into
X * an integral number of hours and the remaining number of minutes.
X * Note that the last two arguments must be passed using their
X * addresses so that the function can correctly set those values.
X */
X
Xstatic void ConvertTimeToHM(int time, int *pHours, int *pMinutes)
X{
X    *pHours = time / MinutesPerHour;
X    *pMinutes = time % MinutesPerHour;
X}
END_OF_FILE
if test 1280 -ne `wc -c <'programs/13-Pointers/hours.c'`; then
    echo shar: \"'programs/13-Pointers/hours.c'\" unpacked with wrong size!
fi
# end of 'programs/13-Pointers/hours.c'
fi
if test -f 'programs/13-Pointers/sort.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/13-Pointers/sort.c'\"
else
echo shar: Extracting \"'programs/13-Pointers/sort.c'\" \(2191 characters\)
sed "s/^X//" >'programs/13-Pointers/sort.c' <<'END_OF_FILE'
X/*
X * File: sort.c
X * ------------
X * This file implements the sort.h interface using the selection
X * sort algorithm.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "sort.h"
X
X/* Private function prototypes */
X
Xstatic int FindSmallestInteger(int array[], int low, int high);
Xstatic void SwapInteger(int *p1, int *p2);
X
X/*
X * Function: SortIntegerArray
X * --------------------------
X * This implementation uses an algorithm called selection sort,
X * which can be described in English as follows.  With your left
X * hand, point at each element in the array in turn, starting at
X * index 0.  At each step in the cycle:
X *
X * (1)  Find the smallest element in the range between your left
X *      hand and the end of the array, and point at that element
X *      with your right hand.
X *
X * (2)  Move that element into its correct index position by
X *      switching the elements indicated by your left and right
X *      hands.
X */
X
Xvoid SortIntegerArray(int array[], int n)
X{
X    int lh, rh;
X
X    for (lh = 0; lh < n; lh++) {
X        rh = FindSmallestInteger(array, lh, n-1);
X        SwapInteger(&array[lh], &array[rh]);
X    }
X}
X
X/*
X * Function: FindSmallestInteger
X * Usage: index = FindSmallestInteger(array, low, high);
X * -----------------------------------------------------
X * This function returns the index of the smallest value in the
X * specified array of integers, searching only between the index
X * positions low and high, inclusive.  It operates by keeping track
X * of the index of the smallest so far in the variable spos.  If the
X * index range is empty, the function returns low.
X */
X
Xstatic int FindSmallestInteger(int array[], int low, int high)
X{
X    int i, spos;
X
X    spos = low;
X    for (i = low; i <= high; i++) {
X        if (array[i] < array[spos]) spos = i;
X    }
X    return (spos);
X}
X
X/*
X * Function: SwapInteger
X * Usage: SwapInteger(&i1, &i2);
X * -----------------------------
X * This function swaps the integers i1 and i2.  Note that the
X * parameters to SwapInteger are pointers to the actual values.
X * This technique is known as call by reference.
X */
X
Xstatic void SwapInteger(int *p1, int *p2)
X{
X    int tmp;
X
X    tmp = *p1;
X    *p1 = *p2;
X    *p2 = tmp;
X}
END_OF_FILE
if test 2191 -ne `wc -c <'programs/13-Pointers/sort.c'`; then
    echo shar: \"'programs/13-Pointers/sort.c'\" unpacked with wrong size!
fi
# end of 'programs/13-Pointers/sort.c'
fi
if test -f 'programs/13-Pointers/sort.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/13-Pointers/sort.h'\"
else
echo shar: Extracting \"'programs/13-Pointers/sort.h'\" \(656 characters\)
sed "s/^X//" >'programs/13-Pointers/sort.h' <<'END_OF_FILE'
X/*
X * File: sort.h
X * ------------
X * This file provides an interface to a simple procedure
X * for sorting an integer array into increasing order.
X */
X
X#ifndef _sort_h
X#define _sort_h
X
X/*
X * Function: SortIntegerArray
X * Usage: SortIntegerArray(array, n);
X * ----------------------------------
X * This function sorts the first n elements in array into
X * increasing numerical order.  In order to use this procedure,
X * you must declare the array in the calling program and pass
X * the effective number of elements as the parameter n.
X * In most cases, the array will have a larger allocated
X * size.
X */
X
Xvoid SortIntegerArray(int array[], int n);
X
X#endif
END_OF_FILE
if test 656 -ne `wc -c <'programs/13-Pointers/sort.h'`; then
    echo shar: \"'programs/13-Pointers/sort.h'\" unpacked with wrong size!
fi
# end of 'programs/13-Pointers/sort.h'
fi
if test -f 'programs/13-Pointers/testsort.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/13-Pointers/testsort.c'\"
else
echo shar: Extracting \"'programs/13-Pointers/testsort.c'\" \(2402 characters\)
sed "s/^X//" >'programs/13-Pointers/testsort.c' <<'END_OF_FILE'
X/*
X * File: testsort.c
X * ----------------
X * This program tests the sort.c implementation.  In this example
X * the array is considered to be a list of exam scores.  The
X * test program reads in a list of scores, sorts them, and then
X * displays the sorted list.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X#include "sort.h"
X
X/*
X * Constants
X * ---------
X * MaxScores -- Maximum number of scores
X * Sentinel  -- Value used to terminate input
X */
X
X#define MaxScores 100
X#define Sentinel   -1
X
X/* Private function prototypes */
X
Xstatic int GetIntegerArray(int array[], int max, int sentinel);
Xstatic void PrintIntegerArray(int array[], int n);
X
X/* Main program */
X
Xmain()
X{
X    int scores[MaxScores];
X    int n;
X
X    printf("Enter exam scores, one per line, ending\n");
X    printf("with the sentinel value %d.\n", Sentinel);
X    n = GetIntegerArray(scores, MaxScores, Sentinel);
X    SortIntegerArray(scores, n);
X    printf("\nThe sorted exam scores are:\n");
X    PrintIntegerArray(scores, n);
X}
X
X/*
X * Function: GetIntegerArray
X * Usage: n = GetIntegerArray(array, max, sentinel);
X * -------------------------------------------------
X * This function reads elements into an integer array by
X * reading values, one per line, from the keyboard.  The end
X * of the input data is indicated by the parameter sentinel.
X * The caller is responsible for declaring the array and
X * passing it as a parameter, along with its allocated
X * size.  The value returned is the number of elements
X * actually entered and therefore gives the effective size
X * of the array, which is typically less than the allocated
X * size given by max.  If the user types in more than max
X * elements, GetIntegerArray generates an error.
X */
X
Xstatic int GetIntegerArray(int array[], int max, int sentinel)
X{
X    int n, value;
X
X    n = 0;
X    while (TRUE) {
X        printf(" ? ");
X        value = GetInteger();
X        if (value == sentinel) break;
X        if (n == max) Error("Too many input items for array");
X        array[n] = value;
X        n++;
X    }
X    return (n);
X}
X
X/*
X * Function: PrintIntegerArray
X * Usage: PrintIntegerArray(array, n);
X * -----------------------------------
X * This function displays the first n values in array,
X * one per line, on the console.
X */
X
Xstatic void PrintIntegerArray(int array[], int n)
X{
X    int i;
X
X    for (i = 0; i < n; i++) {
X        printf("%d\n", array[i]);
X    }
X}
END_OF_FILE
if test 2402 -ne `wc -c <'programs/13-Pointers/testsort.c'`; then
    echo shar: \"'programs/13-Pointers/testsort.c'\" unpacked with wrong size!
fi
# end of 'programs/13-Pointers/testsort.c'
fi
if test -f 'programs/14-Strings-Revisited/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/14-Strings-Revisited/Makefile'\"
else
echo shar: Extracting \"'programs/14-Strings-Revisited/Makefile'\" \(992 characters\)
sed "s/^X//" >'programs/14-Strings-Revisited/Makefile' <<'END_OF_FILE'
X# Makefile for cbook/14-Strings-Revisited/programs
X# Created by the ExportAll facility
X# ***************************************************************
X
XPROGRAMS = \
X    invert 
X
X# ***************************************************************
X# Parameters to control Makefile operation
X# Note that the gccx command script must be defined
X
XCC = gccx
XCFLAGS = 
X
X# ***************************************************************
X# Entry to bring the package up to date
X
Xall: $(PROGRAMS)
X
X# ***************************************************************
X# Standard entries to remove files from the directories
X#    tidy    -- eliminate unwanted files
X#    scratch -- delete derived files in preparation for rebuild
X
Xtidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
Xscratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
X# ***************************************************************
X# C compilations
X
Xinvert.o: invert.c
X	$(CC) $(CFLAGS) -c invert.c
X
X
Xinvert: invert.o
X	$(CC) $(CFLAGS) -o invert invert.o
END_OF_FILE
if test 992 -ne `wc -c <'programs/14-Strings-Revisited/Makefile'`; then
    echo shar: \"'programs/14-Strings-Revisited/Makefile'\" unpacked with wrong size!
fi
# end of 'programs/14-Strings-Revisited/Makefile'
fi
if test -f 'programs/14-Strings-Revisited/invert.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/14-Strings-Revisited/invert.c'\"
else
echo shar: Extracting \"'programs/14-Strings-Revisited/invert.c'\" \(2535 characters\)
sed "s/^X//" >'programs/14-Strings-Revisited/invert.c' <<'END_OF_FILE'
X/*
X * File: invert.c
X * --------------
X * This file implements a function InvertName(result, name)
X * that takes a name in standard order (first middle last) and
X * returns a new string in inverted order (last, first middle),
X * which makes it easier to alphabetize the names.  The test
X * program reads in names and prints out their inverted form,
X * stopping when a blank line is entered.
X */
X
X#include <stdio.h>
X#include <string.h>
X#include "genlib.h"
X#include "simpio.h"
X
X/*
X * Constant
X * --------
X * MaxName -- Maximum number of characters in a name
X */
X
X#define MaxName 40
X
X/* Private function prototypes */
X
Xstatic void InvertName(char result[], char name[]);
X
X/* Main program */
X
Xmain()
X{
X    char *standardName;
X    char invertedName[MaxName+1];
X
X    printf("This program converts a name in standard order\n");
X    printf("into inverted order with the last name first.\n");
X    printf("Indicate the end of input with a blank line.\n");
X    while (TRUE) {
X        printf("Name: ");
X        standardName = GetLine();
X        if (strlen(standardName) == 0) break;
X        InvertName(invertedName, standardName);
X        printf("%s\n", invertedName);
X    }
X}
X
X/*
X * Function: InvertName
X * Usage: InvertName(result, name);
X * --------------------------------
X * This function inverts a name from its standard order
X *
X *     First Middle Last
X *
X * into inverted order, which is
X *
X *     Last, First Middle
X *
X * The client must supply an output array called result in which
X * the inverted name will be stored.  That array must contain
X * at least MaxName character positions, plus one for a
X * terminating null character.  If storing the inverted name
X * would exceed that limit, the function generates an error.
X * The output is always one character longer than the input
X * because of the comma, so it is possible to determine the
X * output length immediately.
X *
X * The last name is assumed to consist of all characters in the
X * name string following the last space character.  If there are
X * no space characters in the word, the entire name is copied to
X * the destination array unchanged.
X */
X
Xstatic void InvertName(char result[], char name[])
X{
X    int len;
X    char *sptr;
X
X    len = strlen(name);
X    sptr = strrchr(name, ' ');
X    if (sptr != NULL) len++;
X    if (len > MaxName) Error("Name too long");
X    if (sptr == NULL) {
X        strcpy(result, name);
X    } else {
X        strcpy(result, sptr + 1);
X        strcat(result, ", ");
X        strncat(result, name, sptr - name);
X        result[len] = '\0';
X    }
X}
END_OF_FILE
if test 2535 -ne `wc -c <'programs/14-Strings-Revisited/invert.c'`; then
    echo shar: \"'programs/14-Strings-Revisited/invert.c'\" unpacked with wrong size!
fi
# end of 'programs/14-Strings-Revisited/invert.c'
fi
if test -f 'programs/15-Text-Files/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/15-Text-Files/Makefile'\"
else
echo shar: Extracting \"'programs/15-Text-Files/Makefile'\" \(1629 characters\)
sed "s/^X//" >'programs/15-Text-Files/Makefile' <<'END_OF_FILE'
X# Makefile for cbook/15-Text-Files/programs
X# Created by the ExportAll facility
X# ***************************************************************
X
XPROGRAMS = \
X    showfile \
X    copyfile \
X    ucfile \
X    remcom \
X    linecopy \
X    elements 
X
X# ***************************************************************
X# Parameters to control Makefile operation
X# Note that the gccx command script must be defined
X
XCC = gccx
XCFLAGS = 
X
X# ***************************************************************
X# Entry to bring the package up to date
X
Xall: $(PROGRAMS)
X
X# ***************************************************************
X# Standard entries to remove files from the directories
X#    tidy    -- eliminate unwanted files
X#    scratch -- delete derived files in preparation for rebuild
X
Xtidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
Xscratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
X# ***************************************************************
X# C compilations
X
Xshowfile.o: showfile.c
X	$(CC) $(CFLAGS) -c showfile.c
X
Xcopyfile.o: copyfile.c
X	$(CC) $(CFLAGS) -c copyfile.c
X
Xucfile.o: ucfile.c
X	$(CC) $(CFLAGS) -c ucfile.c
X
Xremcom.o: remcom.c
X	$(CC) $(CFLAGS) -c remcom.c
X
Xlinecopy.o: linecopy.c
X	$(CC) $(CFLAGS) -c linecopy.c
X
Xelements.o: elements.c
X	$(CC) $(CFLAGS) -c elements.c
X
X
Xshowfile: showfile.o
X	$(CC) $(CFLAGS) -o showfile showfile.o
X
Xcopyfile: copyfile.o
X	$(CC) $(CFLAGS) -o copyfile copyfile.o
X
Xucfile: ucfile.o
X	$(CC) $(CFLAGS) -o ucfile ucfile.o
X
Xremcom: remcom.o
X	$(CC) $(CFLAGS) -o remcom remcom.o
X
Xlinecopy: linecopy.o
X	$(CC) $(CFLAGS) -o linecopy linecopy.o
X
Xelements: elements.o
X	$(CC) $(CFLAGS) -o elements elements.o
END_OF_FILE
if test 1629 -ne `wc -c <'programs/15-Text-Files/Makefile'`; then
    echo shar: \"'programs/15-Text-Files/Makefile'\" unpacked with wrong size!
fi
# end of 'programs/15-Text-Files/Makefile'
fi
if test -f 'programs/15-Text-Files/copyfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/15-Text-Files/copyfile.c'\"
else
echo shar: Extracting \"'programs/15-Text-Files/copyfile.c'\" \(1864 characters\)
sed "s/^X//" >'programs/15-Text-Files/copyfile.c' <<'END_OF_FILE'
X/*
X * File: copyfile.c
X * ----------------
X * This program copies one file to another using character I/O.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
X/* Private function prototypes */
X
Xstatic void CopyFile(FILE *infile, FILE *outfile);
Xstatic FILE *OpenUserFile(string prompt, string mode);
X
X/* Main program */
X
Xmain()
X{
X    FILE *infile, *outfile;
X
X    printf("This program copies one file to another.\n");
X    infile = OpenUserFile("Old file: ", "r");
X    outfile = OpenUserFile("New file: ", "w");
X    CopyFile(infile, outfile);
X    fclose(infile);
X    fclose(outfile);
X}
X
X/*
X * Function: CopyFile
X * Usage: CopyFile(infile, outfile);
X * ---------------------------------
X * This function copies the contents of infile to outfile.  The
X * client is responsible for opening these files before calling
X * CopyFile and for closing them afterward.
X */
X
Xstatic void CopyFile(FILE *infile, FILE *outfile)
X{
X    int ch;
X
X    while ((ch = getc(infile)) != EOF) {
X        putc(ch, outfile);
X    }
X}
X
X/*
X * Function: OpenUserFile
X * Usage: fileptr = OpenUserFile(prompt, mode);
X * --------------------------------------------
X * This function prompts the user for a file name using the
X * prompt string supplied by the user and then attempts to
X * open that file with the specified mode.  If the file is
X * opened successfully, OpenUserFile returns the appropriate
X * file pointer.  If the open operation fails, the user is
X * informed of the failure and given an opportunity to enter
X * another file name.
X */
X
Xstatic FILE *OpenUserFile(string prompt, string mode)
X{
X    string filename;
X    FILE *result;
X
X    while (TRUE) {
X        printf("%s", prompt);
X        filename = GetLine();
X        result = fopen(filename, mode);
X        if (result != NULL) break;
X        printf("Can't open the file \"%s\"\n", filename);
X    }
X    return (result);
X}
END_OF_FILE
if test 1864 -ne `wc -c <'programs/15-Text-Files/copyfile.c'`; then
    echo shar: \"'programs/15-Text-Files/copyfile.c'\" unpacked with wrong size!
fi
# end of 'programs/15-Text-Files/copyfile.c'
fi
if test -f 'programs/15-Text-Files/elements.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/15-Text-Files/elements.c'\"
else
echo shar: Extracting \"'programs/15-Text-Files/elements.c'\" \(1591 characters\)
sed "s/^X//" >'programs/15-Text-Files/elements.c' <<'END_OF_FILE'
X/*
X * File: elements.c
X * ----------------
X * This program copies the information from the elements.dat
X * file into a table formatted into fixed-width columns.  The
X * data values in the file are read using fscanf.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
X/*
X * Constants
X * ---------
X * ElementsFile   -- Name of the elements data file
X * MaxElementName -- Maximum length of element name
X * MaxSymbolName  -- Maximum length of element symbol
X */
X
X#define ElementsFile   "elements.dat"
X#define MaxElementName 15
X#define MaxSymbolName   2
X
X/* Main program */
X
Xmain()
X{
X    FILE *infile;
X    char elementName[MaxElementName+1];
X    char elementSymbol[MaxSymbolName+1];
X    char namebuf[MaxElementName+MaxSymbolName+4];
X    int atomicNumber;
X    double atomicWeight;
X    char termch;
X    int nscan;
X
X    infile = fopen(ElementsFile, "r");
X    if (infile == NULL) Error("Can't open %s", ElementsFile);
X    printf("     Element (symbol)    Atomic Weight\n");
X    printf("--------------------------------------\n");
X    while (TRUE) {
X        nscan = fscanf(infile, "%15[^,], %2[^,], %d, %lf%c",
X                               elementName, elementSymbol,
X                               &atomicNumber, &atomicWeight,
X                               &termch);
X        if (nscan == EOF) break;
X        if (nscan != 5 || termch != '\n') {
X            Error("Improper file format");
X        }
X        sprintf(namebuf, "%s (%s)", elementName, elementSymbol);
X        printf("%3d. %-20s %8.3f\n", atomicNumber, namebuf,
X                                     atomicWeight);
X    }
X}
END_OF_FILE
if test 1591 -ne `wc -c <'programs/15-Text-Files/elements.c'`; then
    echo shar: \"'programs/15-Text-Files/elements.c'\" unpacked with wrong size!
fi
# end of 'programs/15-Text-Files/elements.c'
fi
if test -f 'programs/15-Text-Files/elements.dat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/15-Text-Files/elements.dat'\"
else
echo shar: Extracting \"'programs/15-Text-Files/elements.dat'\" \(218 characters\)
sed "s/^X//" >'programs/15-Text-Files/elements.dat' <<'END_OF_FILE'
XHydrogen, H, 1, 1.008
XHelium, He, 2, 4.003
XLithium, Li, 3, 6.939
XBeryllium, Be, 4, 9.012
XBoron, B, 5, 10.811
XCarbon, C, 6, 12.011
XNitrogen, N, 7, 14.007
XOxygen, O, 8, 15.999
XFluorine, F, 9, 18.998
XNeon, Ne, 10, 20.183
END_OF_FILE
if test 218 -ne `wc -c <'programs/15-Text-Files/elements.dat'`; then
    echo shar: \"'programs/15-Text-Files/elements.dat'\" unpacked with wrong size!
fi
# end of 'programs/15-Text-Files/elements.dat'
fi
if test -f 'programs/15-Text-Files/hamlet.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/15-Text-Files/hamlet.txt'\"
else
echo shar: Extracting \"'programs/15-Text-Files/hamlet.txt'\" \(199 characters\)
sed "s/^X//" >'programs/15-Text-Files/hamlet.txt' <<'END_OF_FILE'
XTo be, or not to be: that is the question.
XWhether 'tis nobler in the mind to suffer
XThe slings and arrows of outrageous fortune,
XOr to take arms against a sea of troubles,
XAnd by opposing end them?
END_OF_FILE
if test 199 -ne `wc -c <'programs/15-Text-Files/hamlet.txt'`; then
    echo shar: \"'programs/15-Text-Files/hamlet.txt'\" unpacked with wrong size!
fi
# end of 'programs/15-Text-Files/hamlet.txt'
fi
if test -f 'programs/15-Text-Files/juliet.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/15-Text-Files/juliet.txt'\"
else
echo shar: Extracting \"'programs/15-Text-Files/juliet.txt'\" \(84 characters\)
sed "s/^X//" >'programs/15-Text-Files/juliet.txt' <<'END_OF_FILE'
XWhat's in a name?
XThat which we call a rose
XBy any other name would smell as sweet.
END_OF_FILE
if test 84 -ne `wc -c <'programs/15-Text-Files/juliet.txt'`; then
    echo shar: \"'programs/15-Text-Files/juliet.txt'\" unpacked with wrong size!
fi
# end of 'programs/15-Text-Files/juliet.txt'
fi
if test -f 'programs/15-Text-Files/linecopy.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/15-Text-Files/linecopy.c'\"
else
echo shar: Extracting \"'programs/15-Text-Files/linecopy.c'\" \(2195 characters\)
sed "s/^X//" >'programs/15-Text-Files/linecopy.c' <<'END_OF_FILE'
X/*
X * File: linecopy.c
X * ----------------
X * This program copies one file to another using line I/O.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
X/*
X * Constants
X * ---------
X * MaxLine -- Size of the buffer used in CopyFile
X */
X
X#define MaxLine 100
X
X/* Private function prototypes */
X
Xstatic void CopyFile(FILE *infile, FILE *outfile);
Xstatic FILE *OpenUserFile(string prompt, string mode);
X
X/* Main program */
X
Xmain()
X{
X    FILE *infile, *outfile;
X
X    printf("This program copies one file to another.\n");
X    infile = OpenUserFile("Old file: ", "r");
X    outfile = OpenUserFile("New file: ", "w");
X    CopyFile(infile, outfile);
X    fclose(infile);
X    fclose(outfile);
X}
X
X/*
X * Function: CopyFile
X * Usage: CopyFile(infile, outfile);
X * ---------------------------------
X * This function copies the contents of infile to outfile.  The
X * client is responsible for opening these files before calling
X * CopyFile and for closing them afterward.  This implementation
X * uses line I/O to perform the copy.  Note that this approach
X * works correctly even if the file contains a line longer than
X * MaxLine; long lines are simply copied in pieces.
X */
X
Xstatic void CopyFile(FILE *infile, FILE *outfile)
X{
X    char buffer[MaxLine];
X
X    while (fgets(buffer, MaxLine, infile) != NULL) {
X        fputs(buffer, outfile);
X    }
X}
X
X/*
X * Function: OpenUserFile
X * Usage: fileptr = OpenUserFile(prompt, mode);
X * --------------------------------------------
X * This function prompts the user for a file name using the
X * prompt string supplied by the user and then attempts to
X * open that file with the specified mode.  If the file is
X * opened successfully, OpenUserFile returns the appropriate
X * file pointer.  If the open operation fails, the user is
X * informed of the failure and given an opportunity to enter
X * another file name.
X */
X
Xstatic FILE *OpenUserFile(string prompt, string mode)
X{
X    string filename;
X    FILE *result;
X
X    while (TRUE) {
X        printf("%s", prompt);
X        filename = GetLine();
X        result = fopen(filename, mode);
X        if (result != NULL) break;
X        printf("Can't open the file \"%s\"\n", filename);
X    }
X    return (result);
X}
END_OF_FILE
if test 2195 -ne `wc -c <'programs/15-Text-Files/linecopy.c'`; then
    echo shar: \"'programs/15-Text-Files/linecopy.c'\" unpacked with wrong size!
fi
# end of 'programs/15-Text-Files/linecopy.c'
fi
if test -f 'programs/15-Text-Files/remcom.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/15-Text-Files/remcom.c'\"
else
echo shar: Extracting \"'programs/15-Text-Files/remcom.c'\" \(2570 characters\)
sed "s/^X//" >'programs/15-Text-Files/remcom.c' <<'END_OF_FILE'
X/*
X * File: remcom.c
X * --------------
X * This program eliminates comments from a file.  This version
X * does not ignore comments that appear in a string constant;
X * that change is left to the reader as an exercise.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
X/* Private function prototypes */
X
Xstatic void CopyRemovingComments(FILE *infile, FILE *outfile);
Xstatic FILE *OpenUserFile(string prompt, string mode);
X
X/* Main program */
X
Xmain()
X{
X    FILE *infile;
X
X    printf("This program removes comments from a file.\n");
X    infile = OpenUserFile("Input file:  ", "r");
X    CopyRemovingComments(infile, stdout);
X    fclose(infile);
X}
X
X/*
X * Function: CopyRemovingComments
X * Usage: CopyRemovingComments(infile, outfile);
X * ---------------------------------------------
X * This function copies one file to another, removing comments
X * as it goes.  The status indicator as to whether a comment is
X * being read is stored in commentFlag.
X */
X
Xstatic void CopyRemovingComments(FILE *infile, FILE *outfile)
X{
X    int ch, nch;
X    bool commentFlag;
X
X    commentFlag = FALSE;
X    while ((ch = getc(infile)) != EOF) {
X        if (commentFlag) {
X            if (ch == '*') {
X                nch = getc(infile);
X                if (nch == '/') {
X                    commentFlag = FALSE;
X                } else {
X                    ungetc(nch, infile);
X                }
X            }
X        } else {
X            if (ch == '/') {
X                nch = getc(infile);
X                if (nch == '*') {
X                    commentFlag = TRUE;
X                } else {
X                    ungetc(nch, infile);
X                }
X            }
X            if (!commentFlag) putc(ch, outfile);
X        }
X    }
X}
X
X/*
X * Function: OpenUserFile
X * Usage: fileptr = OpenUserFile(prompt, mode);
X * --------------------------------------------
X * This function prompts the user for a file name using the
X * prompt string supplied by the user and then attempts to
X * open that file with the specified mode.  If the file is
X * opened successfully, OpenUserFile returns the appropriate
X * file pointer.  If the open operation fails, the user is
X * informed of the failure and given an opportunity to enter
X * another file name.
X */
X
Xstatic FILE *OpenUserFile(string prompt, string mode)
X{
X    string filename;
X    FILE *result;
X
X    while (TRUE) {
X        printf("%s", prompt);
X        filename = GetLine();
X        result = fopen(filename, mode);
X        if (result != NULL) break;
X        printf("Can't open the file \"%s\"\n", filename);
X    }
X    return (result);
X}
END_OF_FILE
if test 2570 -ne `wc -c <'programs/15-Text-Files/remcom.c'`; then
    echo shar: \"'programs/15-Text-Files/remcom.c'\" unpacked with wrong size!
fi
# end of 'programs/15-Text-Files/remcom.c'
fi
if test -f 'programs/15-Text-Files/showfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/15-Text-Files/showfile.c'\"
else
echo shar: Extracting \"'programs/15-Text-Files/showfile.c'\" \(658 characters\)
sed "s/^X//" >'programs/15-Text-Files/showfile.c' <<'END_OF_FILE'
X/*
X * File: showfile.c
X * ----------------
X * This program reads a file name from the user and displays
X * the contents of that file on the console.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X
X/* Main program */
X
Xmain()
X{
X    string filename;
X    FILE *infile;
X    char ch;
X
X    printf("This program displays an input file.\n");
X    while (TRUE) {
X        printf("Input file name: ");
X        filename = GetLine();
X        infile = fopen(filename, "r");
X        if (infile != NULL) break;
X        printf("Can't open the file %s.  Try again.\n", filename);
X    }
X    while ((ch = getc(infile)) != EOF) {
X        putc(ch, stdout);
X    }
X}
END_OF_FILE
if test 658 -ne `wc -c <'programs/15-Text-Files/showfile.c'`; then
    echo shar: \"'programs/15-Text-Files/showfile.c'\" unpacked with wrong size!
fi
# end of 'programs/15-Text-Files/showfile.c'
fi
if test -f 'programs/15-Text-Files/ucfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/15-Text-Files/ucfile.c'\"
else
echo shar: Extracting \"'programs/15-Text-Files/ucfile.c'\" \(1455 characters\)
sed "s/^X//" >'programs/15-Text-Files/ucfile.c' <<'END_OF_FILE'
X/*
X * File: ucfile.c
X * --------------
X * This program updates the contents of a file by converting all
X * letters to upper case.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include "genlib.h"
X#include "simpio.h"
X
X/* Private function prototypes */
X
Xstatic void UpperCaseCopy(FILE *infile, FILE *outfile);
X
X/* Main program */
X
Xmain()
X{
X    string filename, temp;
X    FILE *infile, *outfile;
X
X    printf("This program converts a file to upper case.\n");
X    while (TRUE) {
X        printf("File name: ");
X        filename = GetLine();
X        infile = fopen(filename, "r");
X        if (infile != NULL) break;
X        printf("File %s not found -- try again.\n", filename);
X    }
X    temp = tmpnam(NULL);
X    outfile = fopen(temp, "w");
X    if (outfile == NULL) Error("Can't open temporary file");
X    UpperCaseCopy(infile, outfile);
X    fclose(infile);
X    fclose(outfile);
X    if (remove(filename) != 0 || rename(temp, filename) != 0) {
X        Error("Unable to rename temporary file");
X    }
X}
X
X/*
X * Function: UpperCaseCopy
X * Usage: UpperCaseCopy(infile, outfile);
X * --------------------------------------
X * This function copies the contents of infile to outfile,
X * converting alphabetic characters to upper case as it does so.
X * The client is responsible for opening and closing the files.
X */
X
Xstatic void UpperCaseCopy(FILE *infile, FILE *outfile)
X{
X    int ch;
X
X    while ((ch = getc(infile)) != EOF) {
X        putc(toupper(ch), outfile);
X    }
X}
END_OF_FILE
if test 1455 -ne `wc -c <'programs/15-Text-Files/ucfile.c'`; then
    echo shar: \"'programs/15-Text-Files/ucfile.c'\" unpacked with wrong size!
fi
# end of 'programs/15-Text-Files/ucfile.c'
fi
if test -f 'programs/15-Text-Files/witches.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/15-Text-Files/witches.txt'\"
else
echo shar: Extracting \"'programs/15-Text-Files/witches.txt'\" \(64 characters\)
sed "s/^X//" >'programs/15-Text-Files/witches.txt' <<'END_OF_FILE'
XDouble, double toil and trouble:
XFire burn and cauldron bubble.
END_OF_FILE
if test 64 -ne `wc -c <'programs/15-Text-Files/witches.txt'`; then
    echo shar: \"'programs/15-Text-Files/witches.txt'\" unpacked with wrong size!
fi
# end of 'programs/15-Text-Files/witches.txt'
fi
if test -f 'programs/16-Records/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/16-Records/Makefile'\"
else
echo shar: Extracting \"'programs/16-Records/Makefile'\" \(1322 characters\)
sed "s/^X//" >'programs/16-Records/Makefile' <<'END_OF_FILE'
X# Makefile for cbook/16-Records/programs
X# Created by the ExportAll facility
X# ***************************************************************
X
XPROGRAMS = \
X    employee \
X    point \
X    empdb \
X    teach 
X
X# ***************************************************************
X# Parameters to control Makefile operation
X# Note that the gccx command script must be defined
X
XCC = gccx
XCFLAGS = 
X
X# ***************************************************************
X# Entry to bring the package up to date
X
Xall: $(PROGRAMS)
X
X# ***************************************************************
X# Standard entries to remove files from the directories
X#    tidy    -- eliminate unwanted files
X#    scratch -- delete derived files in preparation for rebuild
X
Xtidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
Xscratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
X# ***************************************************************
X# C compilations
X
Xemployee.o: employee.c
X	$(CC) $(CFLAGS) -c employee.c
X
Xpoint.o: point.c
X	$(CC) $(CFLAGS) -c point.c
X
Xempdb.o: empdb.c
X	$(CC) $(CFLAGS) -c empdb.c
X
Xteach.o: teach.c
X	$(CC) $(CFLAGS) -c teach.c
X
X
Xemployee: employee.o
X	$(CC) $(CFLAGS) -o employee employee.o
X
Xpoint: point.o
X	$(CC) $(CFLAGS) -o point point.o
X
Xempdb: empdb.o
X	$(CC) $(CFLAGS) -o empdb empdb.o
X
Xteach: teach.o
X	$(CC) $(CFLAGS) -o teach teach.o
END_OF_FILE
if test 1322 -ne `wc -c <'programs/16-Records/Makefile'`; then
    echo shar: \"'programs/16-Records/Makefile'\" unpacked with wrong size!
fi
# end of 'programs/16-Records/Makefile'
fi
if test -f 'programs/16-Records/advent.dat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/16-Records/advent.dat'\"
else
echo shar: Extracting \"'programs/16-Records/advent.dat'\" \(1751 characters\)
sed "s/^X//" >'programs/16-Records/advent.dat' <<'END_OF_FILE'
XWelcome to ADVENTURE!
X1
XYou are standing at the end of a road before a
Xsmall brick building.  A small stream flows out
Xof the building and down a gully to the south.
XA road runs up a small hill to the west.
X-----
Xsouth: 2
Xs:     2
Xnorth: 8
Xn:     8
Xin:    8
Xwest:  9
Xw:     9
Xquit:  0
Xq:     0
X
X2
XYou are in a valley in the forest beside a stream
Xtumbling along a rocky bed.  The stream is flowing
Xto the south.
X-----
Xsouth: 3
Xs:     3
Xdown:  3
Xd:     3
Xnorth: 1
Xn:     1
Xquit:  0
Xq:     0
X
X3
XAt your feet all the water of the stream splashes
Xdown a two-inch slit in the rock.  To the south,
Xthe streambed is bare rock.
X-----
Xnorth: 2
Xn:     2
Xsouth: 4
Xs:     4
Xdown:  4
Xquit:  0
Xq:     0
X
X4
XYou are in a 20-foot depression floored with bare
Xdirt.  Set into the dirt is a strong steel grate
Xmounted in concrete.  A dry streambed leads into
Xthe depression from the north.
XThe grate is open.
X-----
Xnorth: 3
Xn:     3
Xup:    3
Xu:     3
Xdown:  5
Xd:     5
Xquit:  0
Xq:     0
X
X5
XYou are in a small chamber beneath a 3x3 steel grate
Xto the surface.  A low crawl leads over cobbles to
Xthe west.
XThe grate is open.
X-----
Xwest:  6
Xw:     6
Xup:    4
Xu:     4
Xquit:  0
Xq:     0
X
X6
XYou are crawling over cobbles into a low east/west
Xpassage.  There is a dim light to the east.
X-----
Xeast:  5
Xe:     5
Xwest:  7
Xw:     7
Xquit:  0
Xq:     0
X
X7
XIt is now pitch dark.  If you proceed you will likely
Xfall into a pit.
X-----
Xeast:  6
Xe:     6
Xxyzzy: 8
Xwest:  0
Xw:     0
Xquit:  0
Xq:     0
X
X8
XYou are inside a building, a well house for a large
Xspring.
X-----
Xout:   1
Xsouth: 1
Xs:     1
Xxyzzy: 7
Xquit:  0
Xq:     0
X
X9
XYou are on a road at the top of a small hill.  You
Xcan see a small brick building at the end of the road
Xto the east.
X-----
Xeast:  1
Xe:     1
Xquit:  0
Xq:     0
END_OF_FILE
if test 1751 -ne `wc -c <'programs/16-Records/advent.dat'`; then
    echo shar: \"'programs/16-Records/advent.dat'\" unpacked with wrong size!
fi
# end of 'programs/16-Records/advent.dat'
fi
if test -f 'programs/16-Records/cs.dat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/16-Records/cs.dat'\"
else
echo shar: Extracting \"'programs/16-Records/cs.dat'\" \(1737 characters\)
sed "s/^X//" >'programs/16-Records/cs.dat' <<'END_OF_FILE'
XC programming review
X1
XWould you like help with int or bool type?
X-----
Xint:     2
Xbool:   10
X
X2
XTrue or false: Integers can have fractional parts.
X-----
Xtrue:    3
Xfalse:   5
X
X3
XNo.  Floating-point numbers have fractional parts;
Xintegers do not.
XTrue or false: Integers can be negative.
X-----
Xtrue:    5
Xfalse:   4
X
X4
XNo.  You should go back and review the text.
XWould you like to quit?
X-----
Xyes:     0
Xy:       0
Xno:      1
Xn:       1
X
X5
XWhat is the value of 17 % 4?
X   a.  0
X   b.  1
X   c.  3
X   d.  4
X-----
Xa:       6
X0:       6
Xb:       7
X1:       7
Xc:       6
X3:       6
Xd:       6
X4:       6
X
X6
XNo.  Try again.
XWhat is the value of 23 % 7?
X   a.  2
X   b.  3
X   c.  6
X   d.  7
X-----
Xa:       7
Xb:       6
Xc:       6
Xd:       6
X
X7
XYes.  That is correct.
XWould you like to choose another topic?
X-----
Xyes:     1
Xno:      0
X
X10
XBoolean review.
XHow many values are there of type bool.
X-----
X1:      11
X2:      13
X3:      11
Xmany:   11
X
X11
XNo, there are only two booleans: TRUE and FALSE.
X
XThe C operator used to indicate the English idea of
X"and" in a Boolean expression is:
X   a.  &
X   b.  &&
X   c.  AND
X   d.  none of the above
X-----
Xa:      12
Xb:      14
Xc:      12
Xd:      12
X
X12
XNo, that is incorrect.
X
XThe C operator used to indicate the English idea of
X"and" in a Boolean expression is:
X   a.  &
X   b.  &&
X   c.  AND
X   d.  none of the above
X-----
Xa:      12
Xb:      14
Xc:      12
Xd:      12
X
X13
XYes, that is correct.
X
XThe C operator used to indicate the English idea of
X"and" in a Boolean expression is:
X   a.  &
X   b.  &&
X   c.  AND
X   d.  none of the above
X-----
Xa:      12
Xb:      14
Xc:      12
Xd:      12
X
X14
XYes, you seem to have mastered boolean data.
XWould you like to choose another topic?
X-----
Xyes:     1
Xno:      0
END_OF_FILE
if test 1737 -ne `wc -c <'programs/16-Records/cs.dat'`; then
    echo shar: \"'programs/16-Records/cs.dat'\" unpacked with wrong size!
fi
# end of 'programs/16-Records/cs.dat'
fi
if test -f 'programs/16-Records/empdb.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/16-Records/empdb.c'\"
else
echo shar: Extracting \"'programs/16-Records/empdb.c'\" \(3065 characters\)
sed "s/^X//" >'programs/16-Records/empdb.c' <<'END_OF_FILE'
X/*
X * File: empdb.c
X * -------------
X * This program tests the functions defined for employees
X * collected into a database.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "strlib.h"
X#include "simpio.h"
X
X/*
X * Constants
X * ---------
X * MaxEmployees -- Maximum number of employees
X */
X
X#define MaxEmployees 100
X
X/*
X * Type: employeeT
X * ---------------
X * This structure defines the fields for an employee.
X */
X
Xtypedef struct {
X    string name;
X    string title;
X    string ssnum;
X    double salary;
X    int withholding;
X} *employeeT;
X
X/*
X * Type: employeeDB
X * ----------------
X * This structure represents an entire database of employees.
X */
X
Xtypedef struct {
X    employeeT staff[MaxEmployees];
X    int nEmployees;
X} *employeeDB;
X
X/* Private function declarations */
X
X
Xstatic employeeDB ReadEmployeeDatabase(void);
Xstatic employeeT ReadOneEmployee(void);
Xstatic void ListEmployees(employeeDB db);
Xstatic void GiveRaise(employeeDB db);
Xstatic double AverageSalary(employeeDB db);
X
X/* Main program */
X
Xmain()
X{
X    employeeDB db;
X
X    db = ReadEmployeeDatabase();
X    ListEmployees(db);
X    printf("Average salary = %g\n", AverageSalary(db));
X    GiveRaise(db);
X    printf("Average after raises = %g\n", AverageSalary(db));
X}
X
Xstatic employeeDB ReadEmployeeDatabase(void)
X{
X    employeeDB db;
X    employeeT emp;
X    int nEmployees;
X
X    db = New(employeeDB);
X    nEmployees = 0;
X    printf("Enter employee data (use blank name to stop).\n");
X    while ((emp = ReadOneEmployee()) != NULL) {
X        db->staff[nEmployees] = emp;
X        nEmployees++;
X    }
X    db->nEmployees = nEmployees;
X    return (db);
X}
X
X/*
X * Function: ReadOneEmployee
X * Usage: emp = ReadOneEmployee();
X * -------------------------------
X * This function reads in the data for a single employee
X * and returns the structure pointer as a value of type
X * employee.  If the user types in a blank line as the
X * name, the function treats this as a "no more data"
X * indicator and returns the value NULL.
X */
X
Xstatic employeeT ReadOneEmployee(void)
X{
X    employeeT emp;
X    string name;
X
X    printf("Name: ");
X    name = GetLine();
X    if (StringLength(name) == 0) return (NULL);
X    emp = New(employeeT);
X    emp->name = name;
X    printf("Title: ");
X    emp->title = GetLine();
X    printf("SSNum: ");
X    emp->ssnum = GetLine();
X    printf("Salary: ");
X    emp->salary = GetReal();
X    printf("Withholding: ");
X    emp->withholding = GetInteger();
X    return (emp);
X}
X
Xstatic void ListEmployees(employeeDB db)
X{
X    int i;
X
X    for (i = 0; i < db->nEmployees; i++) {
X        printf("%s (%s)\n", db->staff[i]->name,
X                            db->staff[i]->title);
X    }
X}
X
Xstatic void GiveRaise(employeeDB db)
X{
X    int i;
X
X    for (i = 0; i < db->nEmployees; i++) {
X        if (db->staff[i]->withholding >= 5) {
X            db->staff[i]->salary *= 2;
X        }
X    }
X}
X
Xstatic double AverageSalary(employeeDB db)
X{
X    double total;
X    int i;
X
X    total = 0;
X    for (i = 0; i < db->nEmployees; i++) {
X        total += db->staff[i]->salary;
X    }
X    return (total / db->nEmployees);
X}
END_OF_FILE
if test 3065 -ne `wc -c <'programs/16-Records/empdb.c'`; then
    echo shar: \"'programs/16-Records/empdb.c'\" unpacked with wrong size!
fi
# end of 'programs/16-Records/empdb.c'
fi
if test -f 'programs/16-Records/employee.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/16-Records/employee.c'\"
else
echo shar: Extracting \"'programs/16-Records/employee.c'\" \(1974 characters\)
sed "s/^X//" >'programs/16-Records/employee.c' <<'END_OF_FILE'
X/*
X * File: employee.c
X * ----------------
X * This program tests the functions defined for records of type
X * employeeT.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "strlib.h"
X#include "simpio.h"
X
X/*
X * Constants
X * ---------
X * MaxEmployees -- Maximum number of employees
X */
X
X#define MaxEmployees 100
X
X/*
X * Type: employeeT
X * ---------------
X * This structure defines the fields for an employee.
X */
X
Xtypedef struct {
X    string name;
X    string title;
X    string ssnum;
X    double salary;
X    int withholding;
X} employeeT;
X
X/*
X * Global variables
X * ----------------
X * staff       -- Array of employees
X * nEmployees  -- Number of employees
X * manager     -- Used to produce a figure for the code
X */
X
Xstatic employeeT staff[MaxEmployees];
Xstatic int nEmployees;
X
Xstatic employeeT manager = {
X    "Ebenezer Scrooge", "Partner", "271-82-8183", 250.00, 1
X};
X
X/* Private function declarations */
X
Xstatic void InitEmployeeTable(void);
Xstatic void ListEmployees(employeeT staff[], int nEmployees);
Xstatic double AverageSalary(employeeT staff[], int nEmployees);
X
X/* Main program */
X
Xmain()
X{
X    InitEmployeeTable();
X    ListEmployees(staff, nEmployees);
X}
X
Xstatic void InitEmployeeTable(void)
X{
X    employeeT emp;
X
X    emp.name = "Ebenezer Scrooge";
X    emp.title = "Partner";
X    emp.ssnum = "271-82-8183";
X    emp.salary = 250.00;
X    emp.withholding = 1;
X    staff[0] = emp;
X    emp.name = "Bob Cratchit";
X    emp.title = "Clerk";
X    emp.ssnum = "314-15-9265";
X    emp.salary = 15.00;
X    emp.withholding = 7;
X    staff[1] = emp;
X    nEmployees = 2;
X}
X
Xstatic void ListEmployees(employeeT staff[], int nEmployees)
X{
X    int i;
X
X    for (i = 0; i < nEmployees; i++) {
X        printf("%s (%s)\n", staff[i].name, staff[i].title);
X    }
X}
X
Xstatic double AverageSalary(employeeT staff[], int nEmployees)
X{
X    double total;
X    int i;
X
X    total = 0;
X    for (i = 0; i < nEmployees; i++) {
X        total += staff[i].salary;
X    }
X    return (total / nEmployees);
X}
END_OF_FILE
if test 1974 -ne `wc -c <'programs/16-Records/employee.c'`; then
    echo shar: \"'programs/16-Records/employee.c'\" unpacked with wrong size!
fi
# end of 'programs/16-Records/employee.c'
fi
if test -f 'programs/16-Records/point.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/16-Records/point.c'\"
else
echo shar: Extracting \"'programs/16-Records/point.c'\" \(1008 characters\)
sed "s/^X//" >'programs/16-Records/point.c' <<'END_OF_FILE'
X/*
X * File: point.c
X * -------------
X * This program tests the functions defined for the type pointT.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "strlib.h"
X#include "simpio.h"
X
X/*
X * Type: pointT
X * ------------
X * This structure represents a point in the x/y plane.
X */
X
Xtypedef struct {
X    double x, y;
X} pointT;
X
X/* Private function declarations */
X
XpointT CreatePoint(double x, double y);
Xvoid DisplayPoint(pointT p);
XpointT AddPoint(pointT p1, pointT p2);
X
X/* Main program */
X
Xmain()
X{
X    pointT p1, p2;
X    pointT origin;
X
X    origin = CreatePoint(0, 0);
X    p1 = CreatePoint(2, 3);
X    p2 = CreatePoint(4, 3);
X    printf("AddPoint(p1, p2) = ");
X    DisplayPoint(AddPoint(p1, p2));
X    printf("\n");
X}
X
XpointT CreatePoint(double x, double y)
X{
X    pointT p;
X
X    p.x = x;
X    p.y = y;
X    return (p);
X}
X
Xvoid DisplayPoint(pointT p)
X{
X    printf("(%g, %g)", p.x, p.y);
X}
X
XpointT AddPoint(pointT p1, pointT p2)
X{
X    pointT p;
X
X    p.x = p1.x + p2.x;
X    p.y = p1.y + p2.y;
X    return (p);
X}
END_OF_FILE
if test 1008 -ne `wc -c <'programs/16-Records/point.c'`; then
    echo shar: \"'programs/16-Records/point.c'\" unpacked with wrong size!
fi
# end of 'programs/16-Records/point.c'
fi
if test -f 'programs/16-Records/teach.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/16-Records/teach.c'\"
else
echo shar: Extracting \"'programs/16-Records/teach.c'\" \(8506 characters\)
sed "s/^X//" >'programs/16-Records/teach.c' <<'END_OF_FILE'
X/*
X * File: teach.c
X * -------------
X * This program executes a simple programmed instruction course.
X * The course is specified by a data file containing all the
X * course information.  The data structures and the format of
X * the data file are described in Chapter 16.
X */
X
X#include <stdio.h>
X#include <string.h>
X#include <ctype.h>
X
X#include "genlib.h"
X#include "strlib.h"
X#include "simpio.h"
X
X/*
X * Constants
X * ---------
X * MaxQuestions          -- Maximum question number
X * MaxLinesPerQuestion   -- Maximum number of lines per question
X * MaxAnswersPerQuestion -- Maximum answers per question
X * EndMarker             -- String marking end of question text
X */
X
X#define MaxQuestions          100
X#define MaxLinesPerQuestion    20
X#define MaxAnswersPerQuestion  10
X#define EndMarker "-----"
X
X/* Data structures */
X
X/*
X * Type: answerT
X * -------------
X * This structure provides space for each possible answer
X * to a question.
X */
X
Xtypedef struct {
X    string ans;
X    int nextq;
X} answerT;
X
X/*
X * Type: questionT
X * ---------------
X * This structure provides space for all the information
X * needed to store one of the individual question records.
X * Because this structure is large and it makes sense
X * to refer to it as a single entity, questionT is defined
X * as a pointer type.
X */
X
Xtypedef struct {
X    string qtext[MaxLinesPerQuestion+1];
X    answerT answers[MaxAnswersPerQuestion];
X    int nAnswers;
X} *questionT;
X
X/*
X * Type: courseDB
X * --------------
X * This type is used to define the entire database, which is
X * a pointer to a record containing the title and an array of
X * questions.
X */
X
Xtypedef struct {
X    string title;
X    questionT questions[MaxQuestions+1];
X} *courseDB;
X
X/* Private function declarations */
X
Xstatic courseDB ReadDataBase(void);
Xstatic bool ReadOneQuestion(FILE *infile, courseDB course);
Xstatic void ReadQuestionText(FILE *infile, questionT q);
Xstatic void ReadAnswers(FILE *infile, questionT q);
Xstatic FILE *OpenUserFile(string prompt, string mode);
Xstatic void ProcessCourse(courseDB course);
Xstatic void AskQuestion(questionT q);
Xstatic int FindAnswer(string ans, questionT q);
X
X/* Main program */
X
Xmain()
X{
X    courseDB course;
X
X    course = ReadDataBase();
X    ProcessCourse(course);
X}
X
X/* Section 1 -- Functions to read the data file */
X
X/*
X * Function: ReadDataBase
X * Usage: ReadDataBase();
X * ----------------------
X * This function asks the user for a file name and reads
X * in the database for the course.  The file is formatted
X * as discussed in the section "Designing the external
X * structure" in Chapter 16.
X */
X
Xstatic courseDB ReadDataBase(void)
X{
X    FILE *infile;
X    courseDB course;
X
X    infile = OpenUserFile("Enter name of course: ", "r");
X    course = New(courseDB);
X    course->title = ReadLine(infile);
X    while (ReadOneQuestion(infile, course));
X    fclose(infile);
X    return (course);
X}
X
X/*
X * Function: ReadOneQuestion
X * Usage: while (ReadOneQuestion(infile, course));
X * -----------------------------------------------
X * This function reads in a single question from infile into the
X * course data structure.  As long as the complete question is
X * read successfully, this function returns TRUE.  When the end
X * of the file is encountered, the function returns FALSE.
X * Thus, the "Usage" line above reads the entire data file.
X */
X
Xstatic bool ReadOneQuestion(FILE *infile, courseDB course)
X{
X    questionT question;
X    string line;
X    int qnum;
X
X    line = ReadLine(infile);
X    if (line == NULL) return (FALSE);
X    qnum = StringToInteger(line);
X    if (qnum < 1 || qnum > MaxQuestions) {
X        Error("Question number %d out of range", qnum);
X    }
X    question = New(questionT);
X    ReadQuestionText(infile, question);
X    ReadAnswers(infile, question);
X    course->questions[qnum] = question;
X    return (TRUE);
X}
X
X/*
X * Function: ReadQuestionText
X * Usage: ReadQuestionText(infile, question);
X * ------------------------------------------
X * This function reads the text of the question into the
X * question data structure, which must have been allocated
X * by the caller.  The end of the question text is signaled
X * by a line matching the string EndMarker.
X */
X
Xstatic void ReadQuestionText(FILE *infile, questionT q)
X{
X    string line;
X    int nlines;
X
X    nlines = 0;
X    while (TRUE) {
X        line = ReadLine(infile);
X        if (StringEqual(line, EndMarker)) break;
X        if (nlines == MaxLinesPerQuestion) {
X            Error("Too many lines");
X        }
X        q->qtext[nlines] = line;
X        nlines++;
X    }
X    q->qtext[nlines] = NULL;
X}
X
X/*
X * Function: ReadAnswers
X * Usage: ReadAnswers(infile, question);
X * -------------------------------------
X * This function reads the answer pairs for the question
X * from the input file.  Each answer consists of a string
X * followed by a colon, followed by the number of the next
X * question to be read.  The end of the answer list is
X * signaled by a blank line or the end of the file.
X */
X
Xstatic void ReadAnswers(FILE *infile, questionT q)
X{
X    string line, ans;
X    int len, cpos, nextq, nAnswers;
X
X    nAnswers = 0;
X    while ((line = ReadLine(infile)) != NULL
X           && (len = StringLength(line)) != 0) {
X        cpos = FindChar(':', line, 0);
X        if (cpos == -1) Error("Illegal answer format");
X        ans = SubString(line, 0, cpos - 1);
X        nextq = StringToInteger(SubString(line, cpos+1, len-1));
X        q->answers[nAnswers].ans = ConvertToUpperCase(ans);
X        q->answers[nAnswers].nextq = nextq;
X        nAnswers++;
X    }
X    q->nAnswers = nAnswers;
X}
X
X/*
X * Function: OpenUserFile
X * Usage: fileptr = OpenUserFile(prompt, mode);
X * --------------------------------------------
X * This function prompts the user for a file name using the
X * prompt string supplied by the user and then attempts to
X * open that file with the specified mode.  If the file is
X * opened successfully, OpenUserFile returns the appropriate
X * file pointer.  If the open operation fails, the user is
X * informed of the failure and given an opportunity to enter
X * another file name.
X */
X
Xstatic FILE *OpenUserFile(string prompt, string mode)
X{
X    string filename;
X    FILE *result;
X
X    while (TRUE) {
X        printf("%s", prompt);
X        filename = GetLine();
X        result = fopen(filename, mode);
X        if (result != NULL) break;
X        printf("Can't open the file \"%s\"\n", filename);
X    }
X    return (result);
X}
X
X/* Section 2 -- Functions to process the course */
X
X/*
X * Function: ProcessCourse
X * Usage: ProcessCourse(course);
X * -----------------------------
X * This function processes the course supplied by the caller.
X * The basic operation consists of a loop that
X *
X *    (a) prints out the current question
X *    (b) reads in an answer
X *    (c) looks up the answer in the database
X *    (d) goes to a new question on the basis of that answer
X *
X * In this implementation, the variable qnum holds the
X * index of the question and the variable q holds the
X * actual question data structure.  The course always begins
X * with question #1, after which the order is determined by
X * the answers.
X */
X
Xstatic void ProcessCourse(courseDB course)
X{
X    questionT q;
X    int qnum;
X    string ans;
X    int index;
X
X    printf("%s\n", course->title);
X    qnum = 1;
X    while (qnum != 0) {
X        q = course->questions[qnum];
X        AskQuestion(q);
X        ans = ConvertToUpperCase(GetLine());
X        index = FindAnswer(ans, q);
X        if (index == -1) {
X            printf("I don't understand that.\n");
X        } else {
X            qnum = q->answers[index].nextq;
X        }
X    }
X}
X
X/*
X * Function: AskQuestion
X * Usage: AskQuestion(q);
X * ----------------------
X * This function asks the question indicated by the questionT
X * specified by q.  Asking the question consists of displaying
X * each of the lines that comprise the question text.
X */
X
Xstatic void AskQuestion(questionT q)
X{
X    int i;
X
X    for (i = 0; q->qtext[i] != NULL; i++) {
X        printf("%s\n", q->qtext[i]);
X    }
X}
X
X/*
X * Function: FindAnswer
X * Usage: FindAnswer(ans, q)
X * -------------------------
X * This function looks up the string ans in the list of answers
X * for question q.  If the answer is found, its index in the
X * answer list is returned.  If not, the function returns -1.
X * The function uses a simple linear search algorithm to look
X * through the array.
X */
X
Xstatic int FindAnswer(string ans, questionT q)
X{
X    int i;
X
X    for (i = 0; i < q->nAnswers; i++) {
X        if (StringEqual(ans, q->answers[i].ans)) return (i);
X    }
X    return (-1);
X}
END_OF_FILE
if test 8506 -ne `wc -c <'programs/16-Records/teach.c'`; then
    echo shar: \"'programs/16-Records/teach.c'\" unpacked with wrong size!
fi
# end of 'programs/16-Records/teach.c'
fi
if test -f 'programs/17-Looking-Ahead/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/17-Looking-Ahead/Makefile'\"
else
echo shar: Extracting \"'programs/17-Looking-Ahead/Makefile'\" \(1593 characters\)
sed "s/^X//" >'programs/17-Looking-Ahead/Makefile' <<'END_OF_FILE'
X# Makefile for cbook/17-Looking-Ahead/programs
X# Created by the ExportAll facility
X# ***************************************************************
X
XPROGRAMS = \
X    qtest \
X    testsort \
X    fact \
X    power \
X    permute 
X
X# ***************************************************************
X# Parameters to control Makefile operation
X# Note that the gccx command script must be defined
X
XCC = gccx
XCFLAGS = 
X
X# ***************************************************************
X# Entry to bring the package up to date
X
Xall: $(PROGRAMS)
X
X# ***************************************************************
X# Standard entries to remove files from the directories
X#    tidy    -- eliminate unwanted files
X#    scratch -- delete derived files in preparation for rebuild
X
Xtidy:
X	rm -f ,* .,* *~ core a.out graphics.ps
X
Xscratch: tidy
X	rm -f *.o *.a $(PROGRAMS)
X
X# ***************************************************************
X# C compilations
X
Xfact.o: fact.c
X	$(CC) $(CFLAGS) -c fact.c
X
Xpower.o: power.c
X	$(CC) $(CFLAGS) -c power.c
X
Xpermute.o: permute.c
X	$(CC) $(CFLAGS) -c permute.c
X
Xqueue.o: queue.c queue.h
X	$(CC) $(CFLAGS) -c queue.c
X
Xqtest.o: qtest.c queue.h
X	$(CC) $(CFLAGS) -c qtest.c
X
Xsort.o: sort.c sort.h
X	$(CC) $(CFLAGS) -c sort.c
X
Xtestsort.o: testsort.c sort.h
X	$(CC) $(CFLAGS) -c testsort.c
X
X
Xqtest: qtest.o queue.o
X	$(CC) $(CFLAGS) -o qtest qtest.o queue.o
X
Xtestsort: testsort.o sort.o
X	$(CC) $(CFLAGS) -o testsort testsort.o sort.o
X
Xfact: fact.o
X	$(CC) $(CFLAGS) -o fact fact.o
X
Xpower: power.o
X	$(CC) $(CFLAGS) -o power power.o
X
Xpermute: permute.o
X	$(CC) $(CFLAGS) -o permute permute.o
END_OF_FILE
if test 1593 -ne `wc -c <'programs/17-Looking-Ahead/Makefile'`; then
    echo shar: \"'programs/17-Looking-Ahead/Makefile'\" unpacked with wrong size!
fi
# end of 'programs/17-Looking-Ahead/Makefile'
fi
if test -f 'programs/17-Looking-Ahead/fact.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/17-Looking-Ahead/fact.c'\"
else
echo shar: Extracting \"'programs/17-Looking-Ahead/fact.c'\" \(1046 characters\)
sed "s/^X//" >'programs/17-Looking-Ahead/fact.c' <<'END_OF_FILE'
X/*
X * File: fact.c
X * ------------
X * This program includes the Factorial function and a test
X * program that prints the factorials of the numbers between
X * the limits LowerLimit and UpperLimit, inclusive.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X
X/*
X * Constants
X * ---------
X * LowerLimit -- Starting value for factorial table
X * UpperLimit -- Final value for factorial table
X */
X
X#define LowerLimit 0
X#define UpperLimit 7
X
X/* Function prototypes */
X
Xint Factorial(int n);
X
X/* Main program */
X
Xmain()
X{
X    int i;
X
X    for (i = LowerLimit; i <= UpperLimit; i++) {
X        printf("%d! = %5d\n", i, Factorial(i));
X    }
X}
X
X/*
X * Function: Factorial
X * Usage: f = Factorial(n);
X * ------------------------
X * This function returns the factorial of the argument n (n!),
X * recursively applying the following mathematical definition:
X *
X *            /  1, if n = 0
X *    n!  =  <
X *            \  n * (n-1)!, if n > 0
X */
X
Xint Factorial(int n)
X{
X    if (n == 0) {
X        return (1);
X    } else {
X        return (n * Factorial(n - 1));
X    }
X}
END_OF_FILE
if test 1046 -ne `wc -c <'programs/17-Looking-Ahead/fact.c'`; then
    echo shar: \"'programs/17-Looking-Ahead/fact.c'\" unpacked with wrong size!
fi
# end of 'programs/17-Looking-Ahead/fact.c'
fi
if test -f 'programs/17-Looking-Ahead/permute.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/17-Looking-Ahead/permute.c'\"
else
echo shar: Extracting \"'programs/17-Looking-Ahead/permute.c'\" \(2071 characters\)
sed "s/^X//" >'programs/17-Looking-Ahead/permute.c' <<'END_OF_FILE'
X/*
X * File: permute.c
X * ---------------
X * This file implements and tests the ListPermutation function.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "strlib.h"
X#include "simpio.h"
X
X/* Private function prototypes */
X
Xstatic void ListPermutations(string str);
Xstatic void PermuteWithFixedPrefix(string str, int k);
Xstatic void ExchangeCharacters(string str, int p1, int p2);
X
X/* Main program */
X
Xmain()
X{
X    string str;
X
X    printf("This program lists all permutations of a string.\n");
X    printf("Enter a string: ");
X    str = GetLine();
X    ListPermutations(str);
X}
X
X/*
X * Function: ListPermutations
X * Usage: ListPermutations(str)
X * ----------------------------
X * This function lists all permutations of the characters
X * in the string str.
X */
X
Xstatic void ListPermutations(string str)
X{
X    PermuteWithFixedPrefix(str, 0);
X}
X
X/*
X * Function: PermuteWithFixedPrefix
X * Usage: PermuteWithFixedPrefix(str, k);
X * --------------------------------------
X * This function implements the recursive permutation algorithm.
X * In English, this function corresponds to the imperative
X * statement: Generate and print all permutations of the string
X * str, holding the first k character fixed.  The recursive insight
X * is that the permutations of n characters consist of each of
X * those characters followed by all permutations of the remaining
X * n-1 characters.
X */
X
Xstatic void PermuteWithFixedPrefix(string str, int k)
X{
X    int i;
X
X    if (k == StringLength(str)) {
X        printf("%s\n", str);
X    } else {
X        for (i = k; i < StringLength(str); i++) {
X            ExchangeCharacters(str, k, i);
X            PermuteWithFixedPrefix(str, k + 1);
X            ExchangeCharacters(str, k, i);
X        }
X    }
X}
X
X/*
X * Function: ExchangeCharacters
X * Usage: ExchangeCharacters(str, p1, p2);
X * ---------------------------------------
X * This function exchanges the characters at positions p1
X * and p2 of the string s.
X */
X
Xstatic void ExchangeCharacters(string str, int p1, int p2)
X{
X    char tmp;
X
X    tmp = str[p1];
X    str[p1] = str[p2];
X    str[p2] = tmp;
X}
END_OF_FILE
if test 2071 -ne `wc -c <'programs/17-Looking-Ahead/permute.c'`; then
    echo shar: \"'programs/17-Looking-Ahead/permute.c'\" unpacked with wrong size!
fi
# end of 'programs/17-Looking-Ahead/permute.c'
fi
if test -f 'programs/17-Looking-Ahead/power.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/17-Looking-Ahead/power.c'\"
else
echo shar: Extracting \"'programs/17-Looking-Ahead/power.c'\" \(1187 characters\)
sed "s/^X//" >'programs/17-Looking-Ahead/power.c' <<'END_OF_FILE'
X/*
X * File: power.c
X * -------------
X * This file includes the RaiseIntToPower function and a
X * simple test program that generates a table of the powers
X * of 2.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X
X/*
X * Constants
X * ---------
X * LowerLimit -- Starting value for power-of-two table
X * UpperLimit -- Final value for power-of-two table
X */
X
X#define LowerLimit  0
X#define UpperLimit 10
X
X/* Function prototypes */
X
Xstatic int RaiseIntToPower(int n, int k);
X
X/* Main program */
X
Xmain()
X{
X    int i;
X
X    printf("Powers of two:\n");
X    for (i = LowerLimit; i <= UpperLimit; i++) {
X        printf(" %2d  %5d\n", i, RaiseIntToPower(2, i));
X    }
X}
X
X/*
X * Function: RaiseIntToPower
X * Usage: result = RaiseIntToPower(n, k);
X * --------------------------------------
X * This function returns n raised to the kth power.  The result
X * is computed by applying the following mathematical definition:
X *
X *             /  1, if k = 0
X *     k      /
X *    n   =  <
X *            \        (k-1)
X *             \  n * n      , otherwise
X */
X
Xstatic int RaiseIntToPower(int n, int k)
X{
X    if (k == 0) {
X        return (1);
X    } else {
X        return (n * RaiseIntToPower(n, k - 1));
X    }
X}
END_OF_FILE
if test 1187 -ne `wc -c <'programs/17-Looking-Ahead/power.c'`; then
    echo shar: \"'programs/17-Looking-Ahead/power.c'\" unpacked with wrong size!
fi
# end of 'programs/17-Looking-Ahead/power.c'
fi
if test -f 'programs/17-Looking-Ahead/qtest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/17-Looking-Ahead/qtest.c'\"
else
echo shar: Extracting \"'programs/17-Looking-Ahead/qtest.c'\" \(1192 characters\)
sed "s/^X//" >'programs/17-Looking-Ahead/qtest.c' <<'END_OF_FILE'
X/*
X * File: qtest.c
X * -------------
X * This program tests the queue.h interface by simulating a
X * simple waiting line.  Entering a name adds that person to
X * the waiting line.  Entering a blank line removes the name
X * at the head of the line and displays it on the screen.
X * Typing "quit" exits from the program.
X */
X
X#include <stdio.h>
X
X#include "genlib.h"
X#include "simpio.h"
X#include "strlib.h"
X#include "queue.h"
X
X/* Main program */
X
Xmain()
X{
X    queueADT waitingLine;
X    string line, name;
X
X    printf("Waiting line manager.\n");
X    printf("Type a name to enter it into the line.\n");
X    printf("Type a blank line to serve the first person in line.\n");
X    printf("Type \"quit\" to exit from the program.\n");
X    waitingLine = NewQueue();
X    while (TRUE) {
X        printf(":");
X        line = GetLine();
X        if (StringEqual(line, "quit")) break;
X        if (StringEqual(line, "")) {
X            if (QueueLength(waitingLine) == 0) {
X                printf("No one is waiting\n");
X            } else {
X                name = Dequeue(waitingLine);
X                printf("%s\n", name);
X            }
X        } else {
X            Enqueue(waitingLine, line);
X        }
X    }
X}
END_OF_FILE
if test 1192 -ne `wc -c <'programs/17-Looking-Ahead/qtest.c'`; then
    echo shar: \"'programs/17-Looking-Ahead/qtest.c'\" unpacked with wrong size!
fi
# end of 'programs/17-Looking-Ahead/qtest.c'
fi
if test -f 'programs/17-Looking-Ahead/queue.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/17-Looking-Ahead/queue.c'\"
else
echo shar: Extracting \"'programs/17-Looking-Ahead/queue.c'\" \(1958 characters\)
sed "s/^X//" >'programs/17-Looking-Ahead/queue.c' <<'END_OF_FILE'
X/*
X * File: queue.c
X * -------------
X * This file implements the queue.h abstraction using an array.
X */
X
X#include <stdio.h>
X
X#include "genlib.h"
X#include "queue.h"
X
X/*
X * Constants:
X * ----------
X * MaxQueueSize -- Maximum number of elements in the queue
X */
X
X#define MaxQueueSize 10
X
X/*
X * Type: queueCDT
X * --------------
X * This type provides the concrete counterpart to the queueADT.
X * The representation used here consists of an array coupled
X * with an integer indicating the effective size.  This
X * representation means that Dequeue must shift the existing
X * elements in the queue.
X */
X
Xstruct queueCDT {
X    void *array[MaxQueueSize];
X    int len;
X};
X
X/* Exported entries */
X
X/*
X * Function: NewQueue
X * ------------------
X * This function allocates and initializes the storage for a
X * new queue.
X */
X
XqueueADT NewQueue(void)
X{
X    queueADT queue;
X
X    queue = New(queueADT);
X    queue->len = 0;
X    return (queue);
X}
X
X/*
X * Function: FreeQueue
X * -------------------
X * This function frees the queue storage.
X */
X
Xvoid FreeQueue(queueADT queue)
X{
X    FreeBlock(queue);
X}
X
X/*
X * Function: Enqueue
X * -----------------
X * This function adds a new element to the queue.
X */
X
Xvoid Enqueue(queueADT queue, void *obj)
X{
X    if (queue->len == MaxQueueSize) {
X        Error("Enqueue called on a full queue");
X    }
X    queue->array[queue->len++] = obj;
X}
X
X/*
X * Function: Dequeue
X * -----------------
X * This function removes and returns the data value at the
X * head of the queue.
X */
X
Xvoid *Dequeue(queueADT queue)
X{
X    void *result;
X    int i;
X
X    if (queue->len == 0) Error("Dequeue of empty queue");
X    result = queue->array[0];
X    for (i = 1; i < queue->len; i++) {
X        queue->array[i - 1] = queue->array[i];
X    }
X    queue->len--;
X    return (result);
X}
X
X/*
X * Function: QueueLength
X * ---------------------
X * This function returns the number of elements in the queue.
X */
X
Xint QueueLength(queueADT queue)
X{
X    return (queue->len);
X}
END_OF_FILE
if test 1958 -ne `wc -c <'programs/17-Looking-Ahead/queue.c'`; then
    echo shar: \"'programs/17-Looking-Ahead/queue.c'\" unpacked with wrong size!
fi
# end of 'programs/17-Looking-Ahead/queue.c'
fi
if test -f 'programs/17-Looking-Ahead/queue.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/17-Looking-Ahead/queue.h'\"
else
echo shar: Extracting \"'programs/17-Looking-Ahead/queue.h'\" \(1401 characters\)
sed "s/^X//" >'programs/17-Looking-Ahead/queue.h' <<'END_OF_FILE'
X/*
X * File: queue.h
X * -------------
X * This file provides an interface to a simple queue
X * abstraction.
X */
X
X#ifndef _queue_h
X#define _queue_h
X
X#include "genlib.h"
X
X/*
X * Type: queueADT
X * --------------
X * This line defines the abstract queue type as a pointer to
X * its concrete counterpart.  Clients have no access to the
X * underlying representation.
X */
X
Xtypedef struct queueCDT *queueADT;
X
X/*
X * Function: NewQueue
X * Usage: queue = NewQueue();
X * --------------------------
X * This function allocates and returns an empty queue.
X */
X
XqueueADT NewQueue(void);
X
X/*
X * Function: FreeQueue
X * Usage: FreeQueue(queue);
X * ------------------------
X * This function frees the storage associated with queue.
X */
X
Xvoid FreeQueue(queueADT queue);
X
X/*
X * Function: Enqueue
X * Usage: Enqueue(queue, obj);
X * ---------------------------
X * This function adds obj to the end of the queue.
X */
X
Xvoid Enqueue(queueADT queue, void *obj);
X
X/*
X * Function: Dequeue
X * Usage: obj = Dequeue(queue);
X * ----------------------------
X * This function removes the data value at the head of the queue
X * and returns it to the client.  Dequeueing an empty queue is
X * an error.
X */
X
Xvoid *Dequeue(queueADT queue);
X
X/*
X * Function: QueueLength
X * Usage: n = QueueLength(queue);
X * ------------------------------
X * This function returns the number of elements in the queue.
X */
X
Xint QueueLength(queueADT queue);
X
X#endif
END_OF_FILE
if test 1401 -ne `wc -c <'programs/17-Looking-Ahead/queue.h'`; then
    echo shar: \"'programs/17-Looking-Ahead/queue.h'\" unpacked with wrong size!
fi
# end of 'programs/17-Looking-Ahead/queue.h'
fi
if test -f 'programs/17-Looking-Ahead/sort.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/17-Looking-Ahead/sort.c'\"
else
echo shar: Extracting \"'programs/17-Looking-Ahead/sort.c'\" \(1915 characters\)
sed "s/^X//" >'programs/17-Looking-Ahead/sort.c' <<'END_OF_FILE'
X/*
X * File: sort.c
X * ------------
X * This file implements the sort.h interface using the merge
X * sort algorithm.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "sort.h"
X
X/* Private function prototypes */
X
Xstatic void Merge(int array[], int arr1[], int n1,
X                               int arr2[], int n2);
X
X/*
X * Function: SortIntegerArray
X * --------------------------
X * This implementation uses an algorithm called merge sort, which
X * consists of the following steps:
X *
X * (1)  Divide the array into two halves.
X * (2)  Sort each half recursively.
X * (3)  Recombine the sorted pieces by calling the Merge function.
X */
X
Xvoid SortIntegerArray(int array[], int n)
X{
X    int i, n1, n2;
X    int *arr1, *arr2;
X
X    if (n > 1) {
X        n1 = n / 2;
X        n2 = n - n1;
X        arr1 = NewArray(n1, int);
X        arr2 = NewArray(n2, int);
X        for (i = 0; i < n1; i++) arr1[i] = array[i];
X        for (i = 0; i < n2; i++) arr2[i] = array[n1 + i];
X        SortIntegerArray(arr1, n1);
X        SortIntegerArray(arr2, n2);
X        Merge(array, arr1, n1, arr2, n2);
X        FreeBlock(arr1);
X        FreeBlock(arr2);
X    }
X}
X
X/*
X * Function: Merge
X * Usage: Merge(array, arr1, n1, arr2, n2);
X * ----------------------------------------
X * This function merges two sorted arrays (arr1 and arr2) into a
X * single array.  Because the input arrays are sorted, the Merge
X * implementation can always select the first unused element in
X * one of the input arrays to fill the next position in array.
X */
X
Xstatic void Merge(int array[], int arr1[], int n1,
X                               int arr2[], int n2)
X{
X    int p, p1, p2;
X
X    p = p1 = p2 = 0;
X    while (p1 < n1 && p2 < n2) {
X        if (arr1[p1] < arr2[p2]) {
X            array[p++] = arr1[p1++];
X        } else {
X            array[p++] = arr2[p2++];
X        }
X    }
X    while (p1 < n1) array[p++] = arr1[p1++];
X    while (p2 < n2) array[p++] = arr2[p2++];
X}
END_OF_FILE
if test 1915 -ne `wc -c <'programs/17-Looking-Ahead/sort.c'`; then
    echo shar: \"'programs/17-Looking-Ahead/sort.c'\" unpacked with wrong size!
fi
# end of 'programs/17-Looking-Ahead/sort.c'
fi
if test -f 'programs/17-Looking-Ahead/sort.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/17-Looking-Ahead/sort.h'\"
else
echo shar: Extracting \"'programs/17-Looking-Ahead/sort.h'\" \(656 characters\)
sed "s/^X//" >'programs/17-Looking-Ahead/sort.h' <<'END_OF_FILE'
X/*
X * File: sort.h
X * ------------
X * This file provides an interface to a simple procedure
X * for sorting an integer array into increasing order.
X */
X
X#ifndef _sort_h
X#define _sort_h
X
X/*
X * Function: SortIntegerArray
X * Usage: SortIntegerArray(array, n);
X * ----------------------------------
X * This function sorts the first n elements in array into
X * increasing numerical order.  In order to use this procedure,
X * you must declare the array in the calling program and pass
X * the effective number of elements as the parameter n.
X * In most cases, the array will have a larger allocated
X * size.
X */
X
Xvoid SortIntegerArray(int array[], int n);
X
X#endif
END_OF_FILE
if test 656 -ne `wc -c <'programs/17-Looking-Ahead/sort.h'`; then
    echo shar: \"'programs/17-Looking-Ahead/sort.h'\" unpacked with wrong size!
fi
# end of 'programs/17-Looking-Ahead/sort.h'
fi
if test -f 'programs/17-Looking-Ahead/testsort.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'programs/17-Looking-Ahead/testsort.c'\"
else
echo shar: Extracting \"'programs/17-Looking-Ahead/testsort.c'\" \(2402 characters\)
sed "s/^X//" >'programs/17-Looking-Ahead/testsort.c' <<'END_OF_FILE'
X/*
X * File: testsort.c
X * ----------------
X * This program tests the sort.c implementation.  In this example
X * the array is considered to be a list of exam scores.  The
X * test program reads in a list of scores, sorts them, and then
X * displays the sorted list.
X */
X
X#include <stdio.h>
X#include "genlib.h"
X#include "simpio.h"
X#include "sort.h"
X
X/*
X * Constants
X * ---------
X * MaxScores -- Maximum number of scores
X * Sentinel  -- Value used to terminate input
X */
X
X#define MaxScores 100
X#define Sentinel   -1
X
X/* Private function prototypes */
X
Xstatic int GetIntegerArray(int array[], int max, int sentinel);
Xstatic void PrintIntegerArray(int array[], int n);
X
X/* Main program */
X
Xmain()
X{
X    int scores[MaxScores];
X    int n;
X
X    printf("Enter exam scores, one per line, ending\n");
X    printf("with the sentinel value %d.\n", Sentinel);
X    n = GetIntegerArray(scores, MaxScores, Sentinel);
X    SortIntegerArray(scores, n);
X    printf("\nThe sorted exam scores are:\n");
X    PrintIntegerArray(scores, n);
X}
X
X/*
X * Function: GetIntegerArray
X * Usage: n = GetIntegerArray(array, max, sentinel);
X * -------------------------------------------------
X * This function reads elements into an integer array by
X * reading values, one per line, from the keyboard.  The end
X * of the input data is indicated by the parameter sentinel.
X * The caller is responsible for declaring the array and
X * passing it as a parameter, along with its allocated
X * size.  The value returned is the number of elements
X * actually entered and therefore gives the effective size
X * of the array, which is typically less than the allocated
X * size given by max.  If the user types in more than max
X * elements, GetIntegerArray generates an error.
X */
X
Xstatic int GetIntegerArray(int array[], int max, int sentinel)
X{
X    int n, value;
X
X    n = 0;
X    while (TRUE) {
X        printf(" ? ");
X        value = GetInteger();
X        if (value == sentinel) break;
X        if (n == max) Error("Too many input items for array");
X        array[n] = value;
X        n++;
X    }
X    return (n);
X}
X
X/*
X * Function: PrintIntegerArray
X * Usage: PrintIntegerArray(array, n);
X * -----------------------------------
X * This function displays the first n values in array,
X * one per line, on the console.
X */
X
Xstatic void PrintIntegerArray(int array[], int n)
X{
X    int i;
X
X    for (i = 0; i < n; i++) {
X        printf("%d\n", array[i]);
X    }
X}
END_OF_FILE
if test 2402 -ne `wc -c <'programs/17-Looking-Ahead/testsort.c'`; then
    echo shar: \"'programs/17-Looking-Ahead/testsort.c'\" unpacked with wrong size!
fi
# end of 'programs/17-Looking-Ahead/testsort.c'
fi
echo shar: End of shell archive.
exit 0
